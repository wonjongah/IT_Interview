##### SJF (Shortest Job First)

- 실행 시간이 가장 짧은 작업 순으로 CPU 수행하는 비선점 스케줄링 기법
- 작업들이 준비상태 큐에 들어와 있으므로 프로세스의 대기시간은 모두 0초부터 계산한다.
- 대기시간 = 첫 수행시간 - 제출시간
- 반환시간 = (실행 끝난 시간 + 1) - 번호



##### HRN (Highest Response-Ratio Next)

- SJF의 약점 보완 기법으로 실행시간이 긴 프로세스를 차별하고 짧은 프로세스를 지나치게 선호하는 점을 보강한 알고리즘으로 각 프로세스의 우선순위를 서비스 시간만이 아니고 서비스 대기시간도 계산하는 스케줄링 기법
- 우선순위 = (대기시간 + 서비스시간) / 서비스 시간



##### CPU 스케줄링 기법

| 구분   | 선점 스케줄링                                                | 비선점 스케줄링                                              |
| ------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 개념   | 한 프로세스가 CPU를 차지하고 있을 때 우선순위가 높은 다른 프로세스를 중지하고 자신이 CPU를 선점. 높은 우선순위를 가진 프로세스들이 빠른 처리를 요구하는 시스템에 유용 | 한 프로세스가 CPU를 차지하고 있으면, 작업 종료 후 CPU 반환 시까지 다른 프로세스는 CPU 선점 불가 |
| 개념도 | if 우선순위 P1 < P2일 때, P2가 중간에 CPU 선점 가능          | if 우선순위가 P1 < P2일 때, P2는 P1 종료 시까지 대기         |
| 장점   | 비교적 빠른 응답. 대화식 시분할 시스템에 적합                | 응답시간 예상이 용이. 모든 프로세스에 대한 요구를 공정하게 처리 |
| 단점   | 높은 우선순위 프로세스들이 들어오는 경우 오버헤드를 초래     | 짧은 작업을 수행하는 프로세스가 긴 작업 종료 시까지 대기     |
| 기법   | RR, SRT, 다단계 큐, 다단계 피드백 큐                         | FCFS, Priority, Deadline, SJF, HRN                           |
| 활용   | 실시간 응답환경, Deadline 응답환경                           | 처리시간 편차가 적은 특정 프로세스 환경                      |



##### 분산 운영 체제의 특징

분산시스템 환경에서 자원 관리와 사용자 인터페이스 기능을 제공하는 시스템 소프트웨어

| 특징                       | 설명                                                         |
| -------------------------- | ------------------------------------------------------------ |
| 자원공유(Resource Sharing) | 한 노드의 사용자와 다른 노드 사용자 간에 유용한 자원들은 공유 |
| 신뢰성 (Reliability)       | 여러 시스템 중 일부 시스템에 고장이 발생하는 경우에도 전체 시스템이 정상적으로 운영 |
| Transparency               | 보수의 컴퓨터를 마치 1대의 기계처럼 다루는 특성으로 특정 자원의 물리적인 위치를 알지 못하여도 사용 가능 |
| Expandability              | 노드들이 통신으로 상호 연결되어 수평적으로 확장              |
| 자율성 (Autonomy)          | 시스템을 구성하는 각 노드들은 각기 어느 정도의 자율성을 가진다. |



##### 교착상태

다중 프로세스 환경 하에 서로 다른 프로세스가 각자 자신이 소유한 자원을 포기하지 않고, 상대 프로세스의 자원을 무한대기하고 있는 상태



##### 교착상태 발생조건

| 원인        | 내용                                                         |
| ----------- | ------------------------------------------------------------ |
| 상호 배제   | 프로세스가 자원을 배타적으로 점유하여 다른 프로세스가 그 자원을 사용할 수 없다. |
| 점유와 대기 | 한 프로세스가 자원을 점유하고 있으면서 또 다른 자원을 요청하여 대기하고 있는 상태 |
| 비선점      | 한 프로세스가 점유한 자원에 대해 다른 프로세스가 선점할 수 없고, 오직 점유한 프로세스만이 해제 가능 |
| 환형 대기   | 두 개 이상의 프로세스 간 자원의 점유와 대기가 하나의 원형을 구성한 상태 |



##### 페이지 결함

기억장치에 적재되지 않은 페이지를 사용하는 현상

콜드 미스 : 데이터를 최초로 읽을 때 발생, 용량 미스 : 메모리 용량이 부족해서 발생

동그라미 친 숫자 -> 처음 메모리에 적재되거나 교체된 데이터 (미스)

동그라미 쳐 있지 않은 숫자는 그 전에 메모리에 적재되어 있는 데이터를 참조 (히트)



##### 가상 메모리 (가상 기억장치)

- <u>주 기억장치 안의 프로그램 양이 많아질 때 사용하지 않는 프로그램을 보조기억장치 안의 특별한 영역으로 옮겨서, 그 보조기억장치 부분을 주기억장치처럼 사용할 수 있는 영역</u>
- 당장 실행할 프로그램만 주 기억장치로 이동
- <u>물리적인 메모리 용량보다 더 큰 용량의 프로그램을 실행할 수 있도록 보조기억장치를 메모리처럼 사용할 수 있도록 하는 가상화 기술</u>



##### 가상 메모리 관리정책

| 관리정책  | 내용                                                         | 기법                           |
| --------- | ------------------------------------------------------------ | ------------------------------ |
| 할당 정책 | 각 프로세스에게 할당할 메모리의 크기를 관리. 실행 중 주기억장치 할당량 변화 알고리즘 | 고정할당 기법, 가변할당 기법   |
| 호출 정책 | 언제 어느 항목들을 보조기억장치에서 주 기억장치에 가져올 것인지 결정 | 요구호출 기법, 예측호출 기법   |
| 배치 정책 | 프로그램의 한 블록을 주기억자치의 어디에 배치할 것인가 관리  | First Fit, Best Fit, Worst Fit |
| 교체 정책 | 주기억장치에 적재할 공간이 없을 경우, 무엇과 교체할 것인가에 대한 관리 | FIFO, LRU, LFU, NUR            |



##### 메모리 인터리빙 기법

