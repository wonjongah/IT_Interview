##### 데이터베이스 이상현상 (Anomaly)

- 이상현상은 정규화를 거치지 않으면 데이터베이스의 데이터들이 불필요하게 중복되어 릴레이션 조작 시 문제가 발생하는데, 이를 이상현상이라고 한다.
- 이상현상의 종류

| 종류            | 설명                                                         |
| --------------- | ------------------------------------------------------------ |
| 삽입 이상       | 테이블에 데이터를 삽입할 때, 의도와는 관계없이 원하지 않는 값들로 인해 삽입할 수 없는 현상 |
| 수정(갱신) 이상 | 테이블에서 튜플에 있는 속성값을 갱신할 때 일부 튜플의 정보만 갱신되어 정보에 불일치성이 생기는 현상 |
| 삭제 이상       | 테이블에서 한 튜플을 삭제할 때, 의도와는 관계 없이 값들도 함께 삭제되면서 연쇄삭제가 일어나는 현상 |



##### 정규화 (Normalization)

- 정규화는 관계형 데이터베이스 설계 시 중복을 최소화하도록 데이터를 구조화하는 프로세스로서 제대로 조직되지 않은 테이블들과 관계들을 작고 잘 조직된 테이블과 관계들로 나누는 무손실 분해를 포함한다.
- 정규화를 수행하는 목적은 다음과 같다.
  - 하나의 테이블에서 데이터의 삽입, 삭제, 변경이 정의된 관계들로 인하여 데이터베이스의 나머지 부분들로 전파되게 하는 것
  - 어떤 관계라도 데이터베이스 내에서 표현이 가능하도록 만드는 것
  - 새로운 형태의 데이터가 삽입될 때 관계를 재구성할 필요성을 줄인다.
  - 보다 간단한 관계 연산에 기초하여 검색을 보다 효율적으로 한다.
- 정규화의 원칙은 낮은 차수의 정규화를 만족한 상태로 높은 차수의 정규화를 진행한다.

| 원칙               | 설명                                                         |
| ------------------ | ------------------------------------------------------------ |
| 무손실 표현        | 같은 의미의 정보 유지하면서 더 바람직한 구조를 만듦          |
| 자료의 중복성 감소 | 중복되는 정보는 삭제하거나 통합                              |
| 분리의 원칙        | 독립적인 관계는 별개의 릴레이션으로 표현하고 릴레이션 각각에 대해 독립적 조작이 가능 |



##### 함수 종속성 (Fucntional Dependency)

- 하나의 릴레이션을 구성하는 속성들의 부분 집합을 X와 Y라고 할 때, 어느 시점에서든 릴레이션 내의 모든 튜플(행)을 대상으로 한 X 값에 대한 Y 값이 항상 하나면 X가 Y를 함수적으로 결정한다고 표현한다.
- X -> Y로 표기하고, Y는 X에 종속된다고 함. (X : 결정자, Y 종속자)
- 함수 종속성의 유형

| 유형             | 개념도                           | 설명                                                         |
| ---------------- | -------------------------------- | ------------------------------------------------------------ |
| 완전 함수 종속   | (A, B) -> C                      | 일반 속성이 식별자 전부에 종속                               |
| 부분 함수 종속   | (A, B) -> C, B -> C              | 일반 속성이 식별자 일부에 종속, 제 2 정규화 필요             |
| 이행 항수 종속   | (A, B) -> C, (A, B) -> D, C -> D | 일반 속성 간 함수적 종속, 제 3 정규화 필요                   |
| 결정자 함수 종속 | (A, B) -> C, C -> B              | 결정자가 후보키가 아닌 경우 존재, 후보키에 종속자 존재. BCNF 정규화 필요 |



##### 정규화의 유형

| 유형                      | 설명                                                         |
| ------------------------- | ------------------------------------------------------------ |
| 제1정규화(1NF)            | 릴레이션 R의 모든 속성 값이 원자값을 가지는 릴레이션         |
| 제2정규화(2NF)            | 릴레이션 R이 제1정규형이고, 기본키가 아닌 속성이 기본키에 완전 함수 종속일 때 |
| 제3정규화(3NF)            | 릴레이션 R이 제2정규형이고, 기본키가 아닌 속성이 기본키에 비이행적 non-transitive으로 종속할 때 (직접 종속) |
| 보이스/코드 정규화 (BCNF) | 릴레이션 R에서 함수 종속성 X -> Y가 성립할 때 모든 결정자 X가 후보키일 때 |
| 제4정규화(4NF)            | 릴레이션 R에서 MVD A ->> B가 존재할 때 R의 모든 속성들이 A에 함수 종속(FD)이면 R은 4NF(즉 R은 모든 속성 X에 대해 A -> X이고 A가 후보키) |
| 제5정규화(5NF)            | 릴레이션 R에 존재하는 모든 조인 종속이 R의 후보키를 통해 성립되면, R은 5NF |

- 정규화의 무손실 과정

비정규 릴레이션 -> 원자값이 아닌 도메인 분해 -> 1NF -> 부분함수 종속 제거 -> 2NF -> 이행 함수 종속 제거 -> 3NF -> 결정자가 후보키가 아닌 함수종속(FD) 제거 -> BCNF -> 함수종속이 아닌 다치종속(MVD) 제거 -> 4NF -> 후보키를 통하지 않은 조인종속(JD) 제거 -> 5NF



##### CRUD Matrix

- 모든 엔티티 목록을 나열하고 각각의 프로세스가 해당 엔티티에 대하여 생성(C), 조회(R), 변경(U), 삭제(D)하는 여부를 표기한 표이다.
- <u>프로세스와 엔터티의 상관관계를 이용해 구축된 엔터티 관계도를 검증 도구</u>
- CRUD Matrix 사례를 점검기준으로 설명하면 다음과 같다.

ex) <u>모든 엔터티에 CRUD가 한 번 이상은 표기되어야 한다</u>

- 엔터티 1의 삭제(D), 엔터티3(UD)가 빠져서 점검기준 불충분
- 엔터티2의, 엔터티4는 CRUD존재, 점검기준 충분

| 프로세스/엔터티 | 엔터티1 | 엔터티2 | 엔터티3 | 엔터티4 |
| --------------- | ------- | ------- | ------- | ------- |
| 프로세스1       | C       |         |         | RUD     |
| 프로세스2       |         | R       | C       |         |
| 프로세스3       | RU      | C       | R       |         |
| 프로세스4       | R       | RUD     |         | C       |



##### 논리적 설계 단계

주 식별자는 개체를 대표하는 유일한 식별자로서 유일성과 최소성을 만족해야 한다. 외래 식별자는 다른 개체를 참조하여 결과의 의미를 가지는 식별자이다.



##### 데이터베이스 키의 특징

| 특징   | 설명                                                         |
| ------ | ------------------------------------------------------------ |
| 유일성 | 하나의 키 값으로 하나의 튜플만을 유일하게 식별할 수 있어야 함. 기본키, 후보키, 슈퍼키 |
| 최소성 | 속성의 집합인 키가 릴레이션의 모든 튜플을 유일하게 식별하기 위해 꼭 필요한 속성들로 구성된 것을 의미. 기본키, 후보키 |



##### 데이터베이스 키 종류

| 종류   | 설명                                                         |
| ------ | ------------------------------------------------------------ |
| 후보키 | 릴레이션을 구성하는 속성들 중에서 튜플을 유일하게 식별할 수 있는 하나 또는 몇 개의 속성의 집합. 유일성과 최소성 모두 만족 (유일성, 최소성 O) |
| 기본키 | 릴레이션의 유일한 식별자(유일성, 최소성 O). 기본키로 지정된 속성은 같은 값을 갖지 못함. 후보키 중에서 선정된 키로 중복값 가질 수 없음. Not null, Unique, 외래키로 참조될 수 있음 |
| 대체키 | 후보키가 둘 이상 되는 경우에 기본키로 선택되지 못한 후보키들. 후보키 = 기본키 + 대체키 |
| 슈퍼키 | 유일성만 있고, 최소성이 없는 속성의 집합 (유일성 O, 최소성 X) |
| 외래키 | 한 테이블의 키 중 다른 테이블의 튜플을 식별할 수 있는 키.    |



##### 클러스터

- 어떤 정해진 속성 값을 기준으로, 동일한 값을 가진 한 이상의 테이블의 튜플을 같은 장소에 저장하는 물리적인 기법.
- 디스크로부터 데이터를 읽어오는 시간을 줄이기 위해서 조인이나 자주 사용되는 테이블의 데이터를 디스크의 같은 위치에 저장시키는 방법.



##### 파티셔닝

대용량의 테이블이나 인덱스의 유지보수 관리가 쉬운 단위로 분리하는 방법.

- 파티셔닝의 단점
  - 테이블간의 조인에 대한 비용 증가
  - 테이블과 인덱스를 별도로 파티션 작업 불가
- 파티셔닝 장점
  - 가용성 : 물리적인 파티셔닝으로 인해 전체 데이터의 훼손 가능성이 줄어들고 데이터 가용성이 향상
  - 관리 용이성 : 큰 테이블들을 제거하여 관리 쉬움
  - 성능 : 특정 DML과 쿼리의 성능을 향상시킴, 주로 대용량 데이터 쓰기 환경에서 효율적이며, 많은 insert가 있는 OLTP시스템에서 삽입 작업들을 분리된 파티션들로 분산시켜 결합을 줄임



##### 인덱스

- 인덱스를 데이터를 빠르게 찾을 수 있는 수단으로서, 테이블에 대한 조회 속도를 높여주는 자료구조로 DDL의 명령어를 이용해 생성, 변경, 삭제 실행.
- 값과 고유주소인 Row_id로 이루어져 있어 데이터가 정렬이 되어 있어 테이블의 데이터 조회 성능이 향상된다.

##### 인덱스 생성

```SQL
CREATE [UNIQUE] INDEX <INDEX NAME> ON <TABLE NAME>(컬럼들); 
```

##### 인덱스 변경

```SQL
ALTER INDEX <INDEX NAME> ON <TABLE NAME>(컬럼들);
```

##### 인덱스 삭제

```SQL
DROP INDEX <INDEX NAME>;
```



##### 뷰(VIEW)

뷰는 허용된 자료만을 제한적으로 보여주기 위해 하나 이상의 테이블로부터 유도된 이름을 가지는 가상테이블이다.

- 뷰의 장점
  - 논리적 독립성 제공 : 뷰는 논리 테이블임
  - 사용자 데이터 관리 용이 : 복수 테이블에 존재하는 여러 종류의 데이터에 대해 단순한 질의어 사용이 가능
  - 데이터 보안 용이 : 중요 보안 데이터를 저장 중인 테이블에는 접근을 불허하고, 해당 테이블의 일부 정보만 뷰를 통해 허용하는 방식으로 데이터에 대한 접근 제어가 가능
- 뷰의 단점
  - 뷰 자체 인덱스 불가 : 인덱스는 물리적으로 저장된 데이터를 대상으로 하기에 논리적 구성인 뷰 자체는 인덱스를 가지지 못함.
  - 뷰 정의 변경 불가 : 뷰의 정의를 변경하려면 뷰를 삭제하고 재생성
  - 데이터 변경 제약 존재 : 뷰의 내용에 대한 삽입, 삭제, 변경 제약

##### 뷰 생성

```SQL
CREATE VIEW <VIEW NAME> AS <뷰를 통해 보여줄 데이터 조회용 SELECT 쿼리문>;
```

##### 뷰 삭제

```SQL
DROP VIEW <VIEW NAME> [RESTRICT | CASCADE];
-- RESTRICT : 뷰를 다른 곳에서 참조하고 있으면 삭제가 취소
-- CASCADE : 뷰를 참조하는 다른 뷰나 제약조건까지 모두 삭제
```



##### 관계 (Relation)

- 개체들 사이에 존재하는 연관이나 연결로서 두 개 이상의 개체 타입들 사이의 사상으로 생각할 수 있으며 관계 집합은 동질의 관계들의 집합을 말하며, 관계 타입은 동질의 관계들의 틀이다.
- E-R 다이어그램에서 관계는 다이아몬드로 표기하며, 관계 타입이 서로 연관시키는 개체 타입들을 관계 타입에 실선으로 연결하며 관계의 특징을 나타내는 속성을 가질 수 있으나, 키 속성은 갖지 않는다.
- 관계로 연결된 개체 타입들의 개수를 관계의 차수(degree)라고 하며, 실세계에서 가장 흔한 관계는 두 개의 개체 타입을 연결하는 2진 관계이다.



##### 슈퍼/서브 타입 관계

- 슈퍼타입은 상위 공통 데이터의 내용을 담는 타입이며, 서브타입은 하위 분할된 정보를 담는 타입이다.
- 슈퍼타입 기준 엔티티 통합은 슈퍼타입 엔티티를 중심으로 하위 엔티티의 속성을 하나의 테이블로 통합한다.
- 서브타입 기준 엔티티 통합은 슈퍼 타입 속성들을 각각의 서브 타입에 추가하여 서브 타입마다 하나의 테이블로 변환한다.
- -> 여러 엔티티에서 공통 속성이 존재할 경우 속성들을 하나로 묶어 통합하는 데이터 모델링 기법



##### 분산 데이터베이스

- 하나의 데이터베이스 관리 시스템이 여러 CPU에 연결된 저장장치들을 제어하는 형태의 데이터베이스이다.
- 논리적으로 같은 시스템에 속하지만, 컴퓨터 네트워크를 통해 물리적으로 분산되어 있는 데이터들의 모임이다.
- 데이터베이스를 연결하는 빠른 네트워크 환경을 이용하여 데이터베이스를 여러 지역 노드로 위치시켜 사용성/성능 등을 극대화시킨 데이터베이스이다.

- 분산 데이터베이스의 투명성

| 투명성              | 설명                                                         |
| ------------------- | ------------------------------------------------------------ |
| 분할 투명성(단편화) | 하나의 논리적 릴레이션이 여러 단편으로 분하로디어 각 단펴의 사본이 여러 사이트에 저장 |
| 위치 투명성         | 사용하려는 데이터의 저장 장소 명시 불필요, 위치 정보가 시스템 카탈로그에 유지되어야 함 |
| 지역사상 투명성     | 지역 DBMS와 무리적 DB 사이의 매핑 보장. 각 지역 시스템 이름과 무관한 이름 사용 가능 |
| 중복 투명성         | DB 객체가 여러 사이트에 중복되어 있는지 알 필요가 없는 성질  |
| 장애 투명성         | 구성요소의 장애에 무관한 트랜잭션의 원자성 유지              |
| 병행 투명성         | 다수 트랜잭션 동시 수행 시 결과의 일관성 유지, 타임스탬프, 분산 2단계 locking을 이용 구현 |



##### 테이블 크기 계산

```
테이블 크기 = (초기건수 * Row길이 + 발생건수 * Row길이 * 보존기간) / 1024
```



##### 반정규화(비정규화)

- 정규화된 데이터 모델을 통합, 중복, 분리하는 과정으로 의도적으로 정규화 원칙을 위배하는 행위를 말한다.
- 비정규화는 정규화된 엔티티, 속성, 관계를 시스템의 성능 향상, 개발과 운영을 단순화하기 위해 데이터 모델을 통합하는 프로세스이다. 즉, 데이터의 정합성과 데이터의 무결성을 우선으로 할지 데이터베이스 구성의 단순화와 성능을 우선으로 할지를 결정한다.



##### 반정규화(비정규화) 방법

- 테이블 반정규화
  - 테이블 병합
    - 1:1 관계테이블 병합
    - 1:M 관계테이블 병합
    - 슈퍼/서브 타입 관계 테이블 병합
  - 테이블 분할 
    - 수직 분할 : 특정 속성들만 접근이 잦을 때 칼럼을 쪼개서 테이블을 만들어 사용하는 기법이다.
    - 수평 분할 : 스키마는 동일하지만, 그 데이터 값을 이용하는 방법이 튜플별로 구분 지어지는 경우에 사용하는 기법이다.
  - 테이블 추가
    - 중복테이블, 통계테이블, 이력테이블, 부분테이블 추가
- 컬럼 반정규화
  - 중복컬럼 추가
    - 자주 사용하는 컬럼을 추가
    - 조회 성능 향상, 수정 비용 증가
  - 파생 컬럼 추가
    - 사전 값을 계산하여 컬럼에 보관하는 컬럼 추가
    - 계산값(sum, avg) 저장
  - 이력컬럼 추가
    - 이력 테이블에 기능성 컬럼을 추가
    - 최근값 여부, 시작과 종료 일자 등
- 관계 반정규화
  - 중복 관계
    - 조인경로가 많은 경우 관계 추가를 통해 성능을 향상시킴



##### 프로시저 명령어

```SQL
EXECUTE 프로시저명;
DROP PROCEDURE 프로시저명;
```



##### UNION, MINUS, INTERSECT, EXISTS, NOT EXISTS, IN, NOT IN, LIKE, BETWEEN a AND b, where절에 ROWNUM



##### 옵티마이저 (Optimizer)

SQL의 문법적인 오류를 확인하고 통계정보를 활용한 비용을 분석하여 최적의 SQL 실행 계획을 수립하는 DBMS 핵심엔진.

- 옵티마이저의 유형

| 항목     | RBO (Rule Vased Optimizer)   | CBO (Cost Based Optimizer)     |
| -------- | ---------------------------- | ------------------------------ |
| 개념     | 사전의 정의된 rule 기반 계획 | 최소비용 계산 실행 계획 수립   |
| 기준     | 실행 우선순위(Ranking)       | 액세스 비용(cost)              |
| 성능     | 사용자 sql 작성 숙련도       | optimizer 예측성능             |
| 특징     | 실행계획의 예측이 용이함     | 저장된 통계정보의 활용         |
| 고려사항 | 저효율, 사용자의 규칙 이해도 | 예측복잡, 비용산출 공식 정확성 |



