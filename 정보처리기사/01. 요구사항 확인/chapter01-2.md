##### 구조적 다이어그램(Structural Diagram)

- <u>구조적 다이어그램</u>은 <u>시스템의 정적구조와 다양한 추상화 및 구현 수준에서 시스템의 구성 요소, 구성 요소들 간의 관계</u>를 보여준다.
- <u>행위 다이어그램</u>은 <u>시스템 내의 객체들의 동적인 행위를 보여주며, 시간의 변화에 따른 시스템의 연속된 변경을 설명</u>해준다.



##### UML Diagram 종류

| 구분                          | 다이어그램          | 설명                                                         |
| ----------------------------- | ------------------- | ------------------------------------------------------------ |
|                               | Class               | 시스템 내 클래스들의 정적 구조를 표현, 클래스는 객체들의 집합으로 속성과 동작으로 구정 |
|                               | Object              | 클래스의 여러 Object 인스턴스를 나타내는 대신 실제 클래스를 사용함 |
| 구조적 다이어그램(Structural) | Component           | 코드 컴포넌트에 바탕을 둔 코드의 물리적 구조를 표현, 컴포넌트는 논리적 클래스 혹은 클래스 자신의 구현에 대한 정보를 포함하고 실질적인 프로그래밍 작업에 사용함 |
|                               | Deployment          | 시스템 하드웨어와 소프트웨어 간의 물리적 구조를 표현하며, 실질적인 컴퓨터와 Device 간의 관계를 표현하는 데 이용 |
|                               | Package             | 시스템 계층적인 구조를 표현, 클래스들로 이루어진 패키지와 그들 간의 의존 관계를 보여줌 |
|                               | Composite Structure | 전체 클래스 안에 각 컴포넌트 클래스 표현함, 클래스 내부 구조 파악에 용이함 |

| 구분                       | 다이어그램 | 설명                                                         |
| -------------------------- | ---------- | ------------------------------------------------------------ |
|                            | Use Case   | 사용자의 입장에서 본 시스템의 행동을 표현, Use Case들은 시스템의 기능적인 요구를 정의 |
| 행위다이어그램(Behavioral) | State      | 클래스의 객체가 가질 수 있는 모든 가능한 상태와 상태간의 전이를 표현, 진입 조건, 탈출 조건, 상태 전이에 필요한 사건 등 자세한 사항이 기술, 설계 단계에서 클래스 객체의 동적인 행동 방식을 표현하는 데 사용 |
|                            | Activity   | 행위의 순서적 흐름을 표현, 순서도나 병렬적인 처리를 요하는 행위를 표현할 때 사용함 |

| 구분                             | 다이어그램           | 설명                                                         |
| -------------------------------- | -------------------- | ------------------------------------------------------------ |
|                                  | Sequence             | 객체와 객체간의 상호작용을 메시지 흐름으로 표현, 오브젝트 사이에 메시지를 보내는 시간 또는 순서를 보여주기 위해 사용함 |
| 상호작용(Interaction) 다이어그램 | Communication        | 상호작용에 참여하는 객체/컴포넌트 간의 관계를 명시적으로 표현 |
|                                  | Interaction Overview | Activity Diagram과 Sequence Diagram의 혼합, 상호작용에 대한 제어흐름을 표현 |
|                                  | Timing               | 시간적 제약과 객체상태 변화를 표현, 인스턴스 간의 상태전이와 상호작용을 시간 제약으로 표현 |



##### 유즈케이스 다이어그램(Use case Digaram)

- 유즈케이스 다이어그램은 시스템이 제공하는 기능과 서비스 및 관련된 외부 요소를 사용자 관점에서 표현하는 UML 다이어그램이다.
- 유즈케이스는 사용자 관점에서의 기능 요구사항이며 액터는 특정 목적을 위해 시스템에 대해 상호작성을 수행하는 역할을 한다. 시스템은 유즈케이스가 동작하는 영역을 표현한다.
- 유즈케이스 다이어그램 작성 시 비즈니스 분석을 통해 액터를 식별하고 기능별 유즈케이스를 도출한 후 각각의 관계를 명확하게 정의하여 다이어그램을 작성해야 한다.



##### 유즈 케이스 다이어그램 구성요소

| 구성요소             | 내용                                                         | 표기법                        |
| -------------------- | ------------------------------------------------------------ | ----------------------------- |
| Actor(행위자)        | 사용자가 시스템에 대해 수행하는 역할, 시스템과 상호작용하는 사람 또는 사물 | 학생, 교수 (졸라맨 모양)      |
| Use Case(유즈케이스) | 시스템이 제공해야 하는 서비스, Actor가 시스템을 통한 일련의 행위 | 수강신청한다.(타원 안에 표기) |

| 구성요소                            | 내용                                                         | 표기법                              |
| ----------------------------------- | ------------------------------------------------------------ | ----------------------------------- |
|                                     | 연관(Association) - 액터와 유즈케이스 간의 상호작용 관계 표현 | 실선                                |
|                                     | 확장(Extend) - 기본 유즈 케이스 수행 시 특정 조건을 만족해야 할 때 수행하는 유즈 케이스 표현 | 점선의 검정 화살표 위에 <<extend>>  |
| Relation(관계)                      | 포함(Include) - 유즈 케이스를 실행하기 위해 반드시 포함해서 실행되어야 하는 유즈케이스를 표현 | 점선의 검정 화살표 위에 <<include>> |
| - 액터와 유즈 케이스 간의 관계 표현 | 일반화(Generalization) - 유사한 유즈 케이스들이나 액터들을 모아 추상화로 표현 | 실선에 흰 화살표                    |
|                                     | 그룹화(Grouping) - 여러 개의 유즈 케이스를 단순화해서 표현   | 폴더 모양                           |

- 반드시 수행해야 하는 관계는 포함(include)이고, 수행할 수도 있는 관계는 확장(extend)에 해당한다.

| 구성요소       | 내용                                                 | 표기법             |
| -------------- | ---------------------------------------------------- | ------------------ |
| System(시스템) | 전체 시스템의 여역을 표현, 특별한 의미를 가지지 못함 | 네모칸으로 감싼다. |



##### 애자일(Agile) 개발 프로세스

- 어느 특정 개발 방법론을 가리키는 말은 아니며 애자일(Agile : 기민한, 좋은 것을 빠르고 낭비 없게 만드는 것) 개발을 가능하게 해주는 다양한 방법론 전체를 일컫는 말이다. 과거에는 애자일 개발 프로세스는 경량 프로세스로 불리었다.
- 익스트림 프로그래밍(XP)이 애자일의 개발 프로세스의 대표적인 방법이다.



##### 애자일 방법론의 종류

| 종류                    | 내용                                                         |
| ----------------------- | ------------------------------------------------------------ |
| XP(eXtreme Programming) | 의사소통 개선과 즉각적인 피드백에 의한 단순한 코딩으로 SW 품질을 높이기 위한 방법론, 1~3주 반복(iteration), 5가지 가치 : <u>용기, 단순성, 의사소통, 피드백, 존경</u> |
| SCRUM                   | 매일 정해진 시간에 정해진 장소에서 짧은 시간의 개발을 하는 팀을 위한 프로젝트 관리 중심의 방법론, 30일마다 동작 가능한 제품을 제공하는 스프린트(Sprint)를 중심으로 진행함, 백로그(backlog) : 제품과 프로젝트에 대한 요구사항, 스프린트(sprint) : 30일 단위(iteration)의 짧은 개발기간으로 분리해 반복적 수행, 스크럼 미팅 : 매일 스크럼(15분 정도) 미팅으로 오늘과 내일의 해야 할 일의 계획 수립, 스크럼 마스터 : 프로젝트 리더, 스크럼 수행 시 문제 인지 및 이를 해결하려고 노력하는 사람 |
| Lean                    | 린 시스템의 품질 기법을 소프트웨어 개발 시스템에 적용해 프로세스의 낭비요소를 제거 후 결과를 측정, 성과를 분석해서 소프트웨어의 품질을 향상시키는 개발방법론, 7가지 원칙 : 낭비 제거, 품질 내재화, 지식창출, 늦은 확정, 빠른 인도, 사람존중, 전체최적화 |



##### SCRUM(스크럼)

스크럼은 작은 개발팀, 짧은 개발 주기, 팀의 집중력과 생산성을 유지시켜 점진적으로 소프트웨어를 산출하는 대표적인 애자일 개발 방법론이다. 프로덕트 백로그를 통해 제품 요구사항을 수집하고 항목별로 스프린트 백로그를 통해 정의해 반복 개발한다.



##### 스크럼의 특징

| 특징                | 내용                                                 |
| ------------------- | ---------------------------------------------------- |
| 협업 중심           | 팀원들의 협업 중심                                   |
| Sprint 수행         | 통상 30일 단위의 Iteration 주기로 개발               |
| Daily Meeting       | 매일 15분 정도 계획, 실적, Risk 공유                 |
| 프로젝트 관리 강조  | XP와 달리 진행 체계 수립, 역할 정의에 중점           |
| 포괄적 정의 및 포용 | 기존의 개발방법론, 표준, 공학적 접근법의 포괄적 수용 |



##### 스크럼 진행과정

Product Backlog -> Sprint Backlog -> Sprint -> Working increment of the software



##### 스크럼의 구성요소

| 항목                | 내용                                                         |
| ------------------- | ------------------------------------------------------------ |
| Sprint              | Iteration 주기(30일)                                         |
| Product Backlog     | 제품의 요구사항 목록                                         |
| Sprint Backlog      | 해당 Sprint 기간에 수행할 Task의 목록                        |
| Daily Scrum Meeting | 매일 15분 정도 계획, 실적, Risk 공유, Scrum Master가 주관    |
| Review              | Sprint가 완료시 고객 검토, Feed back을 받아서 다음 Product Backlog에 update |
| Retrospective(회고) | Sprint 완료후 Scrum 책임자, 팀원 간 내부 회의, 개선할 점을 도출하고 반영 |



##### 스크럼 구성원별 역할

| 항목          | 내용                                                         |
| ------------- | ------------------------------------------------------------ |
| Product owner | 요구사항을 정의하고, Product Backlog 업데이트                |
| Team          | Product Backlog 구현                                         |
| Scrum Master  | 3자의 입장에서 Product owner와 Team이 Scrum 방법론을 제대로 수행할 수 있도록 지원 |



##### 프로덕트 백로그

스크럼 개발방법론에서 우선위가 매겨진 요구사항목록이다.



##### 프로덕트 백로그 주요항목

| 항목            | 내용                        |
| --------------- | --------------------------- |
| ID              | 고유식별자                  |
| 이름            | 스토리를 설명하는 짧은 이름 |
| 중요도/우선순위 | 스토리의 중요도/우선순위    |
| 추정치          | Effort 추정치               |
| 데모방식        | 스토리의 묘사               |
| 참고            | 기타 참고사항               |



##### 요구사항 추적 매트릭스

- 요구사항 추적 매트릭스는 최종 인도물에 요구사항이 반영되기까지의 프로젝트 생애주기 전 과정을 추적하는 도표이다.
- 또한 프로젝트가 끝날 때 요구사항 문서에 승인된 요구사항이 인도되도록 지원하며, 제품 범위에 대한 변경을 관리하는데 유용한 체계를 제공한다.



##### 시퀀스 다이어그램

- 시퀀스 다이어그램은 액터, 활성객체, 메시지 , 생명선, 제어사각현으로 구성된다. 표현할 객체를 액터 또는 활성객체로 정의하고 <u>객체 간의 의사소통을 메시지로 상호작용</u>을 표현한다.
- 각 객체는 시간 흐름에 따라 생존시간을 생명선으로 표시하고 메시지 처리 동작에 따라 제어사각형을 가지고 활성화 상태를 표현한다.

| 구성요소   | 설명                                                         |
| ---------- | ------------------------------------------------------------ |
| 액터       | 시스템과 상호작용하는 사용자, 외부시스템 표현                |
| 활성객체   | 메시지 상호 작용에 참여하는 대상 표현                        |
| 메시지     | 액터, 활성객체 간 의사소통 표현                              |
| 생명선     | 객체의 생존기간을 의미함                                     |
| 제어사각형 | 객체가 활성화 되어 있는 기간 표현. 객체가 제어를 가지고 정보를 처리하거나 다른 정보를 기다리고 있는 것을 표현함. |



##### 액티비티 다이어그램

- 시스템 내부에 있는 객체의 활동 간의 처리흐름을 모델링하는 범용적인 다이어그램이다.
- 사건 발생에 따른 객체들 간의 <u>행위에 대한 상호관계</u>를 표현한다.
- 대상은 클래스의 처리흐름일 수 있고, 비즈니스 측면의 워크플로우일 수도 있다.

| 구성요소  | 설명                                                         |
| --------- | ------------------------------------------------------------ |
| 활동 상태 | 행위나 작업 등 활동 상태를 표현                              |
| 초기 상태 | 처리 흐름의 시작 지점 표현                                   |
| 종료 상태 | 처리 흐름의 종료되는 지점을 표현                             |
| 전이      | 하나의 상태에서 다른 상태로 제어 흐름을 표현                 |
| 동기화    | 병렬 수행이 시작되거나 모여짐을 표현                         |
| 분기      | 활동 흐름이 조건에 따라 분기됨을 표현                        |
| 구획면    | 시스템이나 업무의 담당자 역할을 구분 표현                    |
| 신호      | 활동 진행 중 신호를 보내는 방식을 표현. 송신 신호 : 객체로 신호를 송신하여 객체 조작. 수신 신호 : 객체에서 신호를 수신하여 처리흐름 시작 |



##### 객체지향 기법에서 접근 제한자

- 접근 제한자는 정보은닉을 위해 다른 객체에게 자신의 정보를 숨기고 자신의 연산만을 통해 접근하도록 한다. 설계 단계에서 주로 클래스 다이어그램에서 사용된다.
- public(+), private(-), protected(#), package(~)



##### UML 스테레오타입

- UML 스테레오타입은 UML 표현기능을 강화하기 위해 클래스나 관계를 나타내기 위한 확장 매커니즘이다.
- 스테레오타입은 모델러 마음대로 정의해서 적용하면 되는 것이고, 특별한 제약이나 규칙은 없다. 각 모델 요소의 << >> 사이에 이름을 부여하면 된다.

| 역할   | 스테레오 타입 표기 | 내용                                                         |
| ------ | ------------------ | ------------------------------------------------------------ |
| 포함   | <<include>>        | 유즈케이스를 실행하기 위해 반드시 포함해서 실행되어야 하는 유즈케이스 표현 |
| 확장   | <<extend>>         | 기본 유즈케이스 수행 시 특정 조건을 만족할 때 수행하는 유즈케이스 표현 |
| 경계   | <<boundary>>       | 시스템과 외부 액터와의 상호작용을 담당하는 클래스 표현       |
| 엔티티 | <<entity>>         | 시스템이 유지해야 하는 정보를 관리하는 기능을 전담하는 클래스 표현 |
| 제어   | <<control>>        | 시스템이 제공하는 기능의 로직 및 제어를 담당하는 클래스 표현 |



##### Lean 개발방법론

TPS를 재정립한 경영방법론인 린 시스템의 품질 기법을 소프트웨어 개발에 적용한 개발 방법론이다.

- 품질 기법
  - 린 공학 품질 기법을 SW 개발 프로세스에 적용
- 낭비요소 제거
  - 낭비요소를 제거하고 7가지 개발원칙 준수



##### Kanban(칸반)

칸반은 workflow를 가시화하고, 작업중인 항목의 제한 및 작업 소요시간을 측정할 수 있는 작업 지시서를 SW개발에 적용한 애자일 방법론이다.

- 워크플로우 가시화
  - 작업을 분할(backlog)하여 작업 지시서(카드)에 기록하여 작업보드에 게시
- WIP (Work in progress) 제한
  - 워크플로우상의 적정한 프로세스 관리, 병목현상 관리를 통한 품질 저하 방지
- Workflow 측정 및 최적화
  - 평균시간, 사이클 타임을 산정하여 소요시간 최소화를 위한 프로세스 최적화



##### Product Backlog

구현할 기능과 특성, 요구사항의 우선순위 나열



##### Sprint Backlog

해당 Sprint 기간 동안 수행되어야 할 Task



##### 모델링

모델링은 실세계의 무리현상을 특정한 목적에 맞추어 이용하기 쉬운 형식으로 표현하는 일을 의미한다.



##### 요구사항 관리 프로세스

- 요구사항 관리프로세스에서는 모든 요구공학 프로세스 단계와 동시에 수행하며, 요구사항에 대한 변경을 제어하고 시스템의 완성도에 대해 이해관계자의 합의 역할 및 책임을 부여한다.
- 요구사항 관리단계에서는 요구사항 협상, 요구사항 기준선, 요구사항 변경관리, 요구사항 확인을 수행한다.

| 구분               | 내용                                                         |
| ------------------ | ------------------------------------------------------------ |
| 요구사항 협상      | 가용한 자원과 수용 가능한 위험 수준에서 구현 가능한 기능을 협상하기 위한 기법 |
| 요구사항 기준선    | 공식적으로 검토되고 합의된 요구사항 명세서                   |
| 요구사항 변경 관리 | 요구사항 기준선을 기반으로 모든 변경을 공식적으로 통제하기 위한 기법 |
| 요구사항 확인      | 구축된 시스템이 이해관계자가 기대한 요구사항에 부합되는지 확인하기 위한 방법 (Verification, Validation) |



##### 객체지향 설계원칙 (SOLID)

| 구분                   | 내용                                                         |
| ---------------------- | ------------------------------------------------------------ |
| 단일 책임 원칙         | <u>객체는 단 하나의 책임만을 가져야 함.</u> 어떤 클래스를 변경해야 하는 이유는 오직 하나뿐이어야 하며, 같은 이유로 변화하는 것끼리 묶고, 다른 이유로 변화하는 것끼리는 분리함 |
| 개방 폐쇄 원칙         | <u>기존의 코드를 변경하지 않으면서 기능을 추가할 수 있는 설계가 되어야 함. 소프트웨어 개체는 확장에는 열려있고, 수정 시에는 닫혀있어야 함</u> |
| 리스코프 치환의 원칙   | <u>일반화 관계에 대한 것으로 자식 클래스는 최소한 자신의 부모 클래스에게서 가능한 행위는 수행할 수 있어야 함.</u> 하위 클래스 및 타입들은 상위 타입들이 사용되는 곳에 대체될 수 있어야 하는 설계 원칙. 자식 클래스가 부모 클래스 기능을 재정의하지 않으면 대체 가능함. |
| 인터페이스 분리의 원칙 | <u>인터페이스를 클라이언트에 특화되도록 분리하라는 설계 원칙. 하나의 일반적인 인터페이스보다 구체적인 여러 개의 인터페이스가 나음</u> |
| 의존성 역전의 법칙     | <u>의존 관계를 맺을 때 변화하기 쉬운 것 또는 자주 변화하는 것보다 변화하기 어렵거나 거의 변화가 없는 것에 의존하라는 것임.</u> 추상화된 것에 의존하게 만들고 구체 클래스에 의존하도록 만들지 않도록 함 |



##### 공통모듈

공통모듈은 날짜 처리를 위한 유틸리티 모듈 등과 같이 전체 프로그램의 기능 중 공통적으로 사용할 수 있는 모듈을 의미한다.

- 공통모듈 작성 원칙

| 구분   | 내용                                                         |
| ------ | ------------------------------------------------------------ |
| 정확성 | 실제 시스템 구현 시 필요한 기능인지 여부를 알 수 있도록 정확하게 작성함 |
| 명확성 | 해당 기능에 대한 일관된 이해와 하나로 해석될 수 있도록 작성함 |
| 완전성 | 시스템의 구현 시 요구사항과 필요한 모든 것을 기술함          |
| 일관성 | 공통 기능 사이에 충돌이 발생하지 않도록 작성함               |
| 추적성 | 해당 기능에 대한 요구사항의 출처와 관련 시스템 등 유기적 관계에 대한 식별이 가능하도록 작성함 |



##### 모듈화

- 모듈화는 소프트웨어의 성능을 향상시키거나 시스템의 수정 및 재사용, 유지 관리를 용이하게 하여 프로그램을 효율적으로 관리할 수 있도록 시스템을 분해하고 추상화하는 기법이다.
- 모듈의 크기가 과도하게 작은 경우 모듈의 개수가 많아져 모듈 간의 통합 비용이 과다 발생하고, 모듈의 크기가 과도하게 크면 모듈 간의 통합 비용이 상대적으로 감소하는 대신 하나의 모듈을 개발하는 데 소요되는 비용이 커지게 된다.



##### 모듈의 독립성 판단 지효 : 응집선, 결합도

- 응집도는 내부의 구성 요소 간 관계의 밀접 정도를 평가되며, 응집도가 높을 수록 필요한 요소들로 구성되어지고 낮을 수록 요소들 간의 관련성이 적은 요소들로 구성된다.

```
기능적 응집도 - 순차적 응집도 - 통신적(교환적) 응집도 - 절차적 응집도 - 시간적 응집도 - 논리적 응집도 - 우연적 응집도
```

응집도 강함																																										응집도 약함

- 결합도는 어떤 모듈이 다른 모듈에 의존하는 정도를 측정하는 척도로 독립적인 모듈이 되기 위해서는 결합도가 낮아야 한다.

```
자료 결합도 - 스탬프 결합도 - 제어 결합도 - 외부 결합도 - 공통 결합도 - 내용 결합도		
```

결합도 약함																												결합도 강함



##### 결합도

결합도는 모듈과 모듈 사이의 관련성이 어느 정도인가를 나타내며, 관련성이 적을 수록 모듈의 독립성이 높아 모듈 간 영향이 작아지게 된다.

품질 측면에서 가장 높은 품질은 자료 결합이며, 내용 결합이 가장 낮다.



##### 결합도의 유형

| 결합도        | 내용                                                         |
| ------------- | ------------------------------------------------------------ |
| 자료 결합도   | 모듈 간의 인터페이스로 전달되는 파라미터를 통해서만 모듈 간의 상호 작용이 일어나는 경우 |
| 스탬프 결합도 | 모듈 간의 인터페이스로 배열이나 오브젝트, 스트럭처 등이 전달되는 경우 |
| 제어 결합도   | 단순 처리할 대상인 값만 전달되는 것이 아니라 어떻게 처리를 해야 한다는 제어 요소가 전달되는 경우 |
| 외부 결합도   | 모듈에서 외부로 선언한 데이터를 다른 모듈에서 참조할 때의 경우로 외부에서 도입된 데이터 포맷, 통신 프로토콜, 또는 디바이스 인터페이스를 공유할 때 주로 발생한다. |
| 공통 결합도   | 파라미터가 아닌 모듈 밖에 선언되어 있는 전역 변수를 참조하고 전역 변수를 갱신하는 식으로 상호 작용하는 경우 |
| 내용 결합도   | 다른 모듈 내부에 있는 변수나 기능을 다른 모듈에서 사용하는 경우 |



##### 응집도

- 응집도는 모듈 내부의 구성 요소 간 관계의 밀접 정도로 평가되며, 응집도가 높을 수록 필요한 요소들로 구성되어 있고 낮을 수록 요소들 간의 관련성이 적은 요소들로 구성되어 진다.
- 품질측면에서 가장 낮은 품질은 우연적 응집도이며 우연적 < 논리적 < 시간적 < 절차적 < 통신적 < 순차적 < 기능적 순으로 높아진다.

- 응집도의 유형

| 응집도        | 내용                                                         |
| ------------- | ------------------------------------------------------------ |
| 기능적 응집도 | 모듈 내부의 모든 기능이 단일한 목적을 위해 수행되는 경우     |
| 순차적 응집도 | 모듈 내에서 한 활동으로부터 나온 출력값을 다른 활동이 사용할 경우 |
| 통신적 응집도 | 동일한 입력과 출력을 사용하여 다른 기능을 수행하는 활동들이 모여 있을 경우 |
| 절차적 응집도 | 모듈이 다수의 관련 기능을 가질 때 모듈 안의 구성 요소들이 그 기능을 순차적으로 수행할 경우 |
| 시간적 응집도 | 연관된 기능이라기보다는 특정 시간에 처리되어야 하는 활동들을 한 모듈에서 처리할 경우 |
| 논리적 응집도 | 유사한 성격을 갖거나 특정 형태로 분류되는 처리 요소들이 한 모듈에서 처리되는 경우 |
| 우연적 응집도 | 모듈 내부의 각 구성 요소들이 연관이 없을 경우                |



##### 소프트웨어 설계와 모델링

- 소프트웨어 설계는 요구사항 분석 단계에서 규명된 필수 기능들의 구체적인 구현 방법을 명시하는 단계로 장치, 프로세스, 시스템을 명확하고 상세하게 정의하며 실현 가능하도록 관련 변형된 기술과 원칙을 적용하는 과정을 말한다.
- 설계 모델링은 소프트웨어에 요구되는 기능과 성능 조건들을 만족하는 소프트웨어의 내부 기능 외에 구조 및 동적 행위들을 모델링하여 표현, 분석, 검증하는 과정이다.



##### 소프트웨어 설계 프로세스

- 구조 모델링 : 소프트웨어를 구성하는 컴포넌트들의 유형, 인터페이스, 내부 설계 구조 및 이들의 상호연결 구조를 모델링한다.
- 행위 모델링 : 소프트웨어의 구성요소들의 기능들과 이들이 언제, 어떠한 순서로 기능을 수행하고 상호작용하는지를 모델링한다.



##### 설계 모델 유형

| 모델유형 | 개요                                                         | 내용                                                         |
| -------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 구조모델 | 시스템의 구성 요소들과 이들 사이의 구조적인 관계와 특성들의 모델링 | 구성요소 : 프로시저, 데이터 구조, 모듈, 파일구조. 시스템 구조 : 구성요소들의 연결 구조, 포함관계 |
| 행위모델 | 시스템의 각 구성 요소들의 기능적 특성들에 대한 모델링. 시스템의 구성요소들이 언제 어떠한 순서로 수행되는가와 같은 동적 특성들의 모델링 | 입/출력 데이터, 데이터 흐름, 데이터 별환, 데이터 저장 등. 상태 전이, 데이터 흐름경로, 사건발생 순서, 실행 경로 등 |



##### 설계 모듈의 동적요소와 정적요소

| 유형      | 정적 요소                                                    | 동적 요소                                                    |
| --------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 구조 모델 | 구성 요소의 유형 및 유형 계통. 구성 요소들의 배열, 결합 관계. 구성 요소들의 인터페이스. 구성 요소들의 상호 작용 채널 | 동적 생성 및 소멸. 동적 결합/연결. 위치 이동, 복제           |
| 행위 모델 | 입력/출력 데이터. 입출력 맵핑. 데이터 흐름 채널              | 제어. 상호작용 프로토콜. 상호 작용 실행 경로. 상태전이. 처리순서, 입/출력 순서, 알고리즘 |



##### 소프트웨어 아키텍처

소프트웨어 아키텍처는 소프트웨어 시스템의 구조를 비롯한 시스템 개발에 중요한 영향을 미치는 결정들로, 소프트웨어 시스템 개발에서 특정 시스템에 대하여 요구되는 기능과 품질을 확보하고 또한 소프트웨어 시스템의 구축 및 지속적인 개선이 용이하도록 하는 역할을 한다.

| 구분                        | 설명                                                         |
| --------------------------- | ------------------------------------------------------------ |
| 소프트웨어 아키텍처의 역할  | 요구사항 분석 활동에 의해 도출된 요구사항을 모두 충족시킬 수 있는 시스템이 만들어지도록 하는 설계 활동으로서 설계 및 구현을 위한 구조적/비구조적 틀을 제공. 틀이란 아키텍처 설계의 결과물로서 실행을 요구하는 결정 또는 모델을 의미. 구조적 틀 : 시스템 개발을 위해 결정된 컴포넌트의 구조모델. 비구조적 틀 : 구조모델 이외의 다른 아키텍처설계의 결정들 |
| 아키텍처 설계의 입력과 출력 | 시스템 개발은 모든 요구사항을 달성대상으로 하지만 아키텍처 설계는 아키텍처에 관련된 대표적인 요구사항들만이 주된 관심의 대상이며, 이와 같은 특별한 요구사항들을 아키텍처 드라이버임. 설계의 결과는 아키텍처를 문서화한 아키텍처 문서가 주된 출력물이 되고 이에 대한 추가적인 관련사항을 정리한 아키텍처 가이드라인이 이차적인 출력물 |



##### 아키텍처 패턴

아키텍처 패턴은 반복적으로 발생하는 문제에 대해 미리 만들어진 솔루션이다.



##### 아키텍처 패턴 사례

1. 계층화 패턴

N-티어 아키텍처 패턴이라고도 불린다. 이는 하위 모듈들의 그룹으로 나눌 수 있는 구조화된 프로그램에서 사용할 수 있다.

각 하위 모듈들은 특정한 수준의 추상화를 제공하며, 각 계층은 다음 상위 계층에 서비스를 제공하며, 각 계층은 다음 사위 계층에 서비스를 제공한다.

2. 클라이언트 - 서버 패턴

하나의 서버와 다수의 클라이언트, 두 부분으로 구성된다. 서버 컴포넌트는 다수의 클라이언트 컴포넌트로 서비스를 제공한다.

클라이언트가 서버에 서비스를 요청하면 서버는 클라이언트에게 적절한 서비스를 제공하며 서버는 계속 클라이언트로부터 요청을 대기한다.

3. 마스터 - 슬레이브 패턴

마스터와 슬레이브, 두 부분으로 구성된다.

마스터 컴포넌트는 동등한 구조를 지닌 슬레이브 컴포넌트들로 작업을 분산하고, 슬레이브가 반환한 결과 값으로부터 최종 결과 값을 계산한다.

4. 파이프 - 필터 패턴

데이터 스트림을 생성하고 처리하는 시스템에서 사용할 수 있다.

각 처리 과정은 필터 컴포넌트에서 이루어지며, 처리되는 데이터는 파이프를 통해 흐른다.

이 파이프는 버퍼링 또는 동기화 목적으로 사용될 수 있다.

5. 브로커 패턴

분리된 컴포넌트들로 이루어진 분산 시스템에서 사용된다. 이 컴포넌트들은 원격 서비스 실행을 통해 서로 상호 작용을 할 수 있다.

브로커 컴포넌트는 컴포넌트 간의 통신을 조정하는 역할을 하며, 서버는 자신의 기능들을 브로커에 넘겨주고, 클라이언트가 브로커에 서비스를 요청하면 브로커는 클라이언트를 자신의 레지스트리에 있는 적합한 서비스로 리디렉션한다.

6. 피어 투 피어 패턴

각 컴포넌트를 피어라고 부른다. 피어는 클라이언트로서 피어에게 서비스를 요청할 수도 있고, 서버로서 각 피어에게 서비스를 제공할 수도 있다.

피어는 클라이언트 또는 서버 혹은 둘 모두로서 동작할 수 있으며, 시간이 지남에 따라 역할이 유동적으로 바뀔 수 있다.

7. 이벤트 - 버스 패턴

주로 이벤트를 처리하며 이벤트 소스, 이벤트 리스너, 채널 그리고 이벤트 버스의 4가지 주요 컴포넌트들을 갖는다. 소스는 이벤트 버스를 통해 특정 채널로 메시지를 발행하며, 리스너는 특정 채널에서 메시지를 구독한다. 리스너는 이전에 구독한 채널에 발행된 메시지에 대해 알림을 받는다.



##### SW 아키텍처 4 + 1 View

- SW 아키텍처 4 + 1 View는 시스템의 여러가지 측면을 고려하기 위해 다양한 관점을 바탕으로 정의되며, UML의 4 + 1 View가 사실상의 표준이다.
- 고객 요구사항을 중심으로 4가지 관점으로 소프트웨어 아키텍처를 설계하는 기법.



##### SW 아키텍처 4 + 1 View의 구성

| 구분          | 설명                                                         |
| ------------- | ------------------------------------------------------------ |
| 사용사례관점  | 시스템의 외부 사용자 관점에서 사용 사례들 간의 관계 정의     |
| 논리관점      | 상위 수준에서 시스템의 논리적인 구조/행위를 클래스 인터페이스, 협력관계로 정의 |
| 구현관점      | 독립적으로 실행되는 컴포넌트와 이들 간 관계를 정의           |
| 프로세스 관점 | 시스템의 병렬처리 및 동기화 처리를 위한 스레드와 프로세스를 정의 |
| 배치관점      | 실행되는 시스템 하드웨어와 소프트웨어 관계를 정의            |



##### 객체지향 프로그래밍 (OOP, Object Oriented Programming)

- 컴퓨터 프로그래밍의 패러다임 중 하나로 컴퓨터 프로그램을 명령어의 목록으로 보는 시각에서 벗어나 여러 개의 독립된 단위, 즉 객체들의 모임으로 파악하고자 하는 것이다. 각각의 객체는 메시지를 주고 받고, 데이터를 처리할 수 있다.
- 프로그램을 유연하고 변경이 용이하게 만들기 때문에 대규모 소프트웨어 개발에 많이 사용된다. 또한 프로그래밍을 더 배우기 쉽게 하고, 소프트웨어 개발과 보수를 간편하게 하며 보다 직관적인 분석을 가능하게 하는 장점을 가지고 있다.



##### 객체지향의 구성

| 구분   | 내용                                                         |
| ------ | ------------------------------------------------------------ |
| 클래스 | 같은 종류의 객체들의 집합에 공통 속성과 행위를 정의함. 객체지향 프로그램의 기본적인 사용자 정의 데이터형임 |
| 객체   | 클래스의 인스턴스. 자신 고유의 데이터를 가지며 클래스에서 정의한 행위를 수행함 |
| 속성   | 객체의 데이터                                                |
| 메소드 | 객체의 행위(함수, 메소드). 클래스로부터 생성된 객체를 사용하는 방법임 |
| 메시지 | 객체 간의 통신을 말함                                        |



##### 객체지향의 기법 (캡추다정상)

| 기법     | 상세내용                                                     |
| -------- | ------------------------------------------------------------ |
| 캡슐화   | 속성과 메소드를 하나로 묶어서 객체로 구성. 유지보수 용이. 재사용성 높아짐. 정보은닉으로 내부자료의 일관성 유지. 종속성 최소화 |
| 추상화   | 공통 성질을 추출해 수퍼클래스로 구성. 객체 중심의 안정된 모델 구축. 현실 세계를 자연스럽게 표현. 분석의 초점이 명확해짐 |
| 다형성   | 동일한 이름의 여러 오퍼레이션을 다른 사양으로 정의 가능. 오버로딩 : 매개변수의 수 또는 타입을 달리하여 구분. 오버라이딩 : 부모클래스의 메소드를 재정의 |
| 정보은닉 | 캡슐화된 항목을 다른 객체로부터 숨김. 메시지 전달에 의해 다른 클래스 내의 메소드가 호출됨 |
| 상속성   | 부모 클래스의 속성과 메소드를 상속받아 사용함. 부모와 자식 클래스 간의 관계가 수퍼 클래스와 서브 클래스로 유지됨. 부모 클래스는 추상적이며, 자식 클래스는 구체적 성질을 가짐 |



##### 다형성

- 다형성은 동일한 이름의 오퍼레이션(메소드)이 각 클래스마다 다른 사양으로 정의될 수 있다는 것을 말한다.
- 하나의 클래스 안에서 사용되는 오버로딩과 상속관계의 클래스에서 사용되는 오버라이딩이 대표적이다.



##### 오버라이딩과 오버로딩

| 구분                | 오버라이딩                                                | 오버로딩                                                   |
| ------------------- | --------------------------------------------------------- | ---------------------------------------------------------- |
| 개념                | 상속개념에서 상위 클래스의 메소드를 하위클래스에서 재정의 | 하나의 클래스 내에서 같은 이름으로 여러 개의 메소드를 정의 |
| 메소드 명           | 상속관계 내 동일                                          | 특정클래스 내 동일                                         |
| 매개변수 개수, 타입 | 반드시 동일                                               | 개수 또는 타입이 다름                                      |
| 리턴 타입           | 기본적으로 동일                                           | 상관없음                                                   |
| 접근제한            | 범위가 같거나 넓어야 함                                   | 상관없음                                                   |



##### 추상화

- 추상화는 실체에서 공통되는 속성이나, 관심 있는 부분만 추출하여 모델링하는 개념이다.
- 객체지향프로그래밍에서는 추상화를 통해 공통 성질을 추출하여 슈퍼클래스로 설정한다.

- 분석의 초점이 명확해짐



##### 팩토리 메소드 패턴

- 팩토리 메소드 패턴은 생성패턴 중에 하나로, 객체를 생성하기 위한 인터페이스를 따로 정의하며 어떤 클래스를 객체를 생성하는 일을 하위 클래스가 담당토록 설계한다.
- 객체들에 대한 클래스의 종류를 예상할 수 없을 때나 객체 생성의 책임을 서브클래스에게 위임시키고 서브클래스에 대한 정보를 은닉하고자 할 경우 사용한다.



##### 팩토리 메소드 패턴의 역할

추상클래스 간의 상호작용을 책임져서 전제 시스템의 기본 동작 방식을 정의하고, 이들 추상 클래스를 상속하는 서브클래스에서 구체적인 행위를 정의함으로써 새로운 애플리케이션을 만들게 한다.



##### 어댑터 패턴

- 어댑터 패턴은 구조패턴 중에 하나이며 클래스의 재사용성을 높이기 위해 요구되는 특정 기능으로 변환/적용하여 클래스 간 호환성을 확보하는 패턴으로 호환성 없는 인터페이스 때문에 함께 사용할 수 없는 클래스 간 호환성을 확보하는 패턴으로 호환성 없는 인터페이스 때문에 함께 사용할 수 없는 클래스를 변경하여 함께 작동하도록 해준다.
- 클래스의 인터페이스를 사용자가 원하는 인터페이스 형태로 변환시켜 서로 일치하지 않는 인터페이스를 갖는 클래스들을 함께 동작할 수 있도록 해준다.



##### 어댑터 패턴의 역할

재사용을 목표로 개발한 프로그램도 적용을 못하는 경우가 발생한 경우 서로 일치하지 않는 인터페이스를 갖는 클래스들을 통합할 때 적용한다.



##### 인터프리터 패턴

- 언어의 다양한 해석, 구체적으로 구문을 나누고 그 분리된 구문의 해석을 맡은 클래스를 각각 작성하여 여러 형태의 언어 구문을 해석할 수 있게 만드는 패턴.
- 인터프리터 패턴은 행위 패턴 중에 하나로 간단한 언어의 문법을 정의하는 방법과 그 언어로 문장을 구성하는 방법, 문장을 해석하는 방법을 제시하는 유용한 패턴이다.



##### 인터프리터 패턴 활용

- 언어를 구현하는 경우에 interpreter pattern에서는 문법과 구문을 번역하기 위한 인터프리터를 표현한 것을 클래스 기반으로 정의한다.
- 문법 규칙의 개수가 많아질 경우나 복잡한 문법은 관리하기 어려운 단점이 있다.



##### 파사드 패턴

- 파사드 패턴에서 Facade(외관)는 건물의 정면을 의미하며 서브시스템이 복잡할 경우 간단한 인터페이스를 통해 서브시스템의 주요기능을 사용할 수 있는 패턴입니다.
- 복잡한 내부 구조를 보이지 않으면서 외부와의 일관된 인터페이스를 제공하는 패턴이다.



##### 파사드 패턴의 사용 목적

- 소프트웨어 라이브러리를 쉽게 사용하고 이해할 수 있게 해준다.
- 공통적인 작업에 대해 간편한 메소드들을 제공해준다.
- High Level API 제공을 통해 외부와의 인터페이스를 단순화할 수 있다.



##### 싱글톤 패턴

싱글톤 패턴은 지정한 클래스의 인스턴스가 반드시 한 개만 존재하도록 하는 패턴으로 클래스에서 만들 수 있는 인스턴스가 오직 하나일 경우에 이에 대한 접근은 어디에서든지 하나로만 통일해 제공한다.



##### 싱글톤 패턴 사용목적

- 클래스의 인스턴스가 오직 하나여야 함을 보장하고, 잘 정의된 접근 방식에 의해 모든 클라이언트가 접근할 수 있도록 해야 할 때 사용한다.



##### 싱글톤 패턴의 사용목적

- 클래스의 인스턴스가 오직 하나여야 함을 보장하고, 잘 정의된 접근 방식에 의해 모든 클라이언트가 접근할 수 있도록 해야 할 때 사용한다.
- 유일하게 존재하는 인스턴스가 상속에 의해 확장되어야 할 때, 클라이언트는 코드 수정 없이 확장된 서브클래스의 인스턴스를 사용할 수 있어야 할 때 사용한다.



##### MVC (Model View Controller) 패턴

- 소프트웨어 공학에서 사용되는 소프트웨어 디자인 패턴으로 사용자 인터페이스로부터 비즈니스 로직을 분리하여 애플리케이션의 시각적 요소나 그 이면에서 실행되는 비즈니스 로직을 서로 영향 없이 쉽게 고칠 수 있는 애플리케이션을 만들 수 있다.
- MVC에서 모델은 애플리케이션의 정보를 나타내며, 뷰는 텍스트, 체크박스 항목 등과 같은 사용자 인터페이스 요소를 나타내고, 컨트롤러는 데이터와 비즈니스 로직 사이의 상호동작을 관리한다.



##### MVC 패턴의 구성

| 모델     | 모델의 상태에 변화가 있을 때 컨트롤러와 뷰에 이를 통보한다. 이와 같은 통보를 통해서 뷰는 최신의 결과를 보여줄 수 있고, 컨트롤러는 모델의 변화에 따른 적용 가능한 명령을 추가, 제거, 수정할 수 있음. 어떤 MVC 구현에서는 통보 대신 뷰나 컨트롤러가 직접 모델의 상태를 읽어 오기도 함 |
| -------- | ------------------------------------------------------------ |
| 뷰       | 사용자가 볼 결과물을 생성하기 위해 모델로부터 정보를 얻어옴  |
| 컨트롤러 | 모델에 명령을 보냄으로써 모델의 상태를 변경할 수 있음. 컨트롤러가 관련된 뷰에 명령을 보냄으로써 모델의 표시 방법을 바꿀 수 있음 |



##### 내외부 인터페이스

내외부 인터페이스란 조직 내/외부에 존재하는 시스템이 연동을 통해 상호 작용하기 위한 접속 방법이나 규칙을 의미하며, 네트워크를 통해 조직 내/외부에 존재하는 시스템 간 요구기능을 수행하기 위해서 내외부 인터페이스 설계와 개발은 필수적이다.



##### 직접 인터페이스 방식

- 일반적으로 중간의 연계 매개체가 생략되어 연계 처리 속도가 빠르고 구현이 단순하며, 개발 비용과 기간이 짧은 장점이 있다.
- 송신 시스템과 수신 시스템 사이의 결합도가 높아 시스템 변경에 민감한 특성이 있다.
- 보안을 위한 암/복호화 처리와 업무 기능 구현을 인터페이스별로 작성하여, 전사 차원의 시스템 인터페이스 통합 환경 구축이 어려운 단점이 있다.



##### 간접 인터페이스 방식

- 연계 서버를 활용하여 송/수신 처리와 송/수신 현황을 모니터링하고 통제하는 방식으로, 서로 상이한 네트워크와 프로토콜 등 다양한 환경의 시스템들을 연계하고 통합 관리할 수 있다.
- 장점으로 인터페이스 변경 시에도 유연하게 대처가 가능하고 보안이나 업무처리 로직 반영이 용이하다.
- 단점으로 인터페이스 아키텍처와 연계 절차가 복잡하고, 연계 서버로 인한 성능 저하, 개발 및 테스트 기간이 직접 연계 방식보다 오래 걸린다.



##### 부치 방법론

- 부치는 요구사항 분석을 하는 과정에서 <u>절차지향 프로그램</u>으로 개발하려면 <u>동사</u>를 식별하고, <u>객체지향 프로그램</u>으로 개발하려면 <u>명사</u>를 선택하라고 했다.
- 미시적 개발 프로세스와 거시적 개발 프로세스를 모두 포함하여 사용한다.
- 클래스와 객체들을 분석 및 식별하고 클래스의 속성과 연산을 정의한다.
- 클래스와 객체의 의미를 식별, 클래스와 객체들의 관계를 식별, 클래스와 객체를 구현한다.
- 각 작업에 대한 다이어그램, 클래스 계층 정의, 클래스들의 클러스터링 작업을 수행한다.
- <u>유즈케이스</u>를 강조하여 사용하는 분석 방법이다.



##### 코드-요든 방법

객체지향 분석 방법론 중 E-R 다이어그램을 사용하여 객체의 행위를 모델링하며, 객체 식별, 구조식별, 주제 정의, 속성과 인스턴스 연결 정의, 연산과 메시지 연결 정의 등의 과정으로 구성되는 것.

E-R 다이어그램은 Coad&Yourdon 분석법 기본 스타일이다.



##### Wirfs-Borck 방법

분석과 설계 간의 구분이 없고 고객 명세서를 평가해서 설계 작업까지 연속적으로 수행하는 기법.



##### 데이터 명세화

인터페이스 요구 사항 분석 과정에서 식별한 연계 정보에 해당하는 개체정의서, 테이블 정의서, 파일 레이아웃(정의서), 코드 정의서 등을 통해 데이터를 명세화라고 한다.



##### 개체 정의서

데이터베이스 개념모델링 단계에서 도출한 개체의 타입과 관련 속성, 식별자 등의 정보를 개괄적으로 명세화한 정의서이다.



##### 개체정의서 중요 내용

- 개체 타입명
  - 데이터베이스에 저장할 개체를 대표할 수 있는 이름
- 속성
  - 개체의 특징 또는 설명 정보
- 식별자
  - 해당 개체를 유일하게 식별할 수 있는 속성



##### 테이블 정의서

- 논리 및 물리 모델링 과정에서 작성하는 설계 산출물로 테이블을 구성하는 컬럼들의 특성, 인덱스, 업무 규칙을 문서화한 것이다.



##### 미들웨어 솔루션

- 미들웨어 솔루션은 기능적으로 클라이언트와 서버 사이의 통신을 담당하는 시스템 소프트웨어를 의미한다.
- 컴퓨터와 컴퓨터의 연결을 담당하는 소프트웨어로 중간을 의미하는 미들과 소프트웨어를 의미하는 웨어의 합성어이다.



##### 미들웨어 솔루션 유형별 활용

| 유형         | 설명 및 활용                                                 |
| ------------ | ------------------------------------------------------------ |
| 데이터베이스 | 데이터베이스 제품 제작업체에서 제공하는 클라이언트와 데이터베이스를 연결하기 위한 미들웨어 |
| RPC          | 응용 프로그램의 프로시저를 사용하여 원격 프로시저를 로컬 프로시저처럼 호출하는 방식의 미들웨어 |
| MOM          | 메시지 기반의 비동기형 메시지 전달 방식 미들웨어. 서로 다른 이기종 분산 데이터 시스템의 데이터 동기를 위하여 주로 사용됨 |
| TP-모니터    | 온라인 업무에서 트랜잭션을 처리, 감시하는 미들웨어. 사용자 수가 증가하여도 빠른 응답 속도를 유지해야 하는 업무에 적합함 |
| ORB          | 코바 표준 스펙을 구현한 객체지향 미들웨어이다. 최근에는 IT-모니터가 가지고 있는 장점을 추가로 구현함 |
| WAS          | 웹 환경을 구현하기 위한 미들웨어. WAS는 HTTP 세션 처리를 위한 웹서버 기능뿐만 아니라 민감한 기업 업무까지 자바, EJB 컴포넌트 기반으로 구현 가능 |



