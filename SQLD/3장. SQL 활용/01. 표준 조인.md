#### USING -> 선택한 컬럼으로 조인 가능, ALIAS X

#### ON -> 명시적으로 보여줄 수 있으며, 이름이 다른 칼럼명을 사용해 조인하거나 임의의 JOIN 조건을 지정할 때 사용, ALIAS O



#### 1. STANDARD SQL 개요



현재 우리가 사용하는 많은 시스템의 두뇌 역할을 하는 관계형 데이터베이스를 유일하게 접속할 수 있는 언어가 SQL이다.

바뀐 점

1. UNION 연산은 UNION 기능으로,
2. INTERSECTION 연산은 INTERSECT 기능으로,
3. DIFFERENCE 연산은 EXCEPT 기능으로,
4. PRODUCT 연산은 CROSS JOIN 기능으로 구현됐다.
5. SELECT 연산은 WHERE 절로 구현되었고,
6. PROJECT 연산은 SELECT 절로 구현되었다.
7. (NATURAL) JOIN 연산은 다양한 JOIN 기능으로 구현되었다.
8. DIVIDE 연산은 현재 사용되지 않는다.



#### 2. FROM 절 JOIN 형태



SQL에서 표시하는 FROM 절의 JOIN 형태는 다음과 같다.

- INNER JOIN
- NATURAL JOIN
- USING 조건절
- ON 조건절
- CROSS JOIN
- OUTER JOIN

기존 WHERE 절의 검색 조건과 테이블 간의 JOIN 조건을 FROM 절에서 명시적으로 정의할 수 있게 되었다.

INNER JOIN은 WHERE 절에서부터 사용하던 JOIN의 DEFAULT 옵션으로 JOIN 조건에서 동일한 값이 있는 행만 반환한다. DEFAULT 옵션이므로 생략이 가능하지만, CROSS JOIN, OUTER JOIN과는 같이 사용할 수 없다.

ON 조건절의 경우 NATURAL JOIN처럼 조건이 숨어 있지 않고, 명시적으로 JOIN 조건을 구분할 수 있고, NATURAL JOIN이나 USING 조건절처럼 칼럼명이 똑같아야 한다는 제약 없이 칼럼명이 상호 다르더라도 JOIN 조건으로 사용할 수 있으므로 앞으로 가장 많이 사용될 것으로 예상된다. 다만, FROM 절에 테이블이 많이 사용될 경우 다소 복잡하게 보여 가독성이 떨어지는 단점이 있다.



#### 3. INNER JOIN

INNER JOIN은 OUTER JOIN과 대비해 내부 JOIN이라고도 하며 <u>JOIN 조건에서 동일한 값이 있는 행만 반환한다.</u>

<u>INNER JOIN 표시는 그동안 WHERE 절에 사용하던 JOIN 조건을 FROM 절에서 정의하겠다는 표시이므로 USING 조건절이나 ON 조건절을 필수적으로 사용해야 한다.</u>



EX) 사원 번호와 사원 이름, 소속부서 코드와 소속부서 이름을 찾아본다.

```SQL
WHERE 절 JOIN 조건 -- 명확하게 드러나지 않음

SELECT EMP.DEPTNO, EMPNO, ENAME, DNAME
FROM EMP, DEPT
WHERE EMP.DEPTNO = DEPT.DEPTNO;

-- 위 SQL와 아래 SQL은 같은 결과를 얻을 수 있다.

FROM 절 JOIN 조건

SELECT EMP.DEPTNO, EMPNO, ENAME, DNAME
FROM EMP INNER JOIN DEPT
ON EMP.DEPTNO = DEPT.DEPTNO;

-- INNER JOIN의 디폴트 옵션으로 아래 SQL문과 같이 생략 가능하다.

SELECT EMP.DEPTNO, EMPNO, ENAME, DNAME
FROM EMP JOIN DEPT
ON EMP.DEPTNO = DEPT.DEPTNO;
```

```
    DEPTNO      EMPNO ENAME                DNAME
---------- ---------- -------------------- ----------------------------
        20       7369 SMITH                RESEARCH
        30       7499 ALLEN                SALES
        30       7521 WARD                 SALES
        20       7566 JONES                RESEARCH
        30       7654 MARTIN               SALES
        30       7698 BLAKE                SALES
        10       7782 CLARK                ACCOUNTING
        20       7788 SCOTT                RESEARCH
        10       7839 KING                 ACCOUNTING
        30       7844 TURNER               SALES
        20       7876 ADAMS                RESEARCH

    DEPTNO      EMPNO ENAME                DNAME
---------- ---------- -------------------- ----------------------------
        30       7900 JAMES                SALES
        20       7902 FORD                 RESEARCH
        10       7934 MILLER               ACCOUNTING
```



#### 4. NATURAL JOIN (명확하게 드러날 때)

NATURAL JOIN은 두 테이블 간의 동일한 이름을 갖는 모든 칼럼들에 대해 EQUI JOIN을 수행한다.

NATURAL JOIN이 명시되면, 추가로 USING 조건절, ON 조건절, WHERE 절에서 JOIN 조건을 정의할 수 없다.

그리고 SQL SERVER에서는 지원하지 않는 기능이다.



EX) 사원 번호와 사원 이름, 소속부서 코드와 소속부서 이름을 찾아본다.

```SQL
SELECT DEPTNO, EMPNO, ENAME, DNAME
FROM EMP NATURAL JOIN DEPT;
-- WHERE 절 생략 가능, 이미 동일조인했다는 뜻
```

위의 SQL은 JOIN 칼럼을 별도로 지정하지 않았디만, 두 개의 테이블에서 DEPTNO라는 공통된 칼럼을 자동으로 인식해서 JOIN을 처리한 것이다.

JOIN에 사용된 칼럼들은 같은 데이터 유형이어야 하고, ALIAS나 테이블 명과 같은 접두사를 붙일 수 없다.

```SQL
SELECT EMP.DEPTNO, EMPNO, ENAME, DNAME
FROM EMP NATURAL JOIN DEPT
-- ERROR : NATURAL JOIN에 사용된 열은 식별자를 가질 수 없다.
```



EX) 아래 * 와일드 카드처럼 별도의 칼럼 순서를 지정하지 않으면 NATURAL JOIN의 기준이 되는 칼럼들이 다른 칼럼보다 먼저 출력된다. (DEPTNO가 첫 번째 칼럼이 된다.) 이때, NATURAL JOIN은 JOIN에 사용된 같은 이름의 칼럼을 하나로 처리한다.

```SQL
SELECT *
FROM EMP NATURAL JOIN DEPT;
```

-> DEPTNO가 먼저 출력, 그리고 DEPTNO은 EMP의 DEPTNO, DEPT.DEPTNO이 따로 출력되지 않고 하나만 출력된다.



EX) 반면 INNER JOIN의 경우 첫 번째 테이블, 두 번째 테이블의 칼럼 순서대로 데이터가 출력된다. 이때 NATURAL JOIN은 JOIN에 사용된 같은 이름의 칼럼을 하나로 처리하지만, INNER JOIN은 별개의 칼럼으로 표시한다.

```
SELELCT *
FROM EMP INNER JOIN DEPT
ON EMP.DEPTNO = DEPT.DEPTNO;
```

-> EMPNO이 먼저 출력되고, EMP.DEPTNO과 DEPT.DEPTNO이 둘 다 출력된다.



EX) NATURAL JOIN과 INNER JOIN의 차이를 설명하기 위해 DEPT_TEMP 테이블을 임시로 만든다.

```SQL
CREATE TABLE DEPT_TEMP
AS SELECT * FROM DEPT;
```

```SQL
UPDATE DEPT_TEMP
SET DNAME = 'r&d'
WHERE DNAME = 'RESEARCH';

UPDATE DEPT_TEMP
SET DNAME = 'MARKETING'
WHERE DNAME = 'SALES';

SELECT * FROM DEPT_TEMP;
```

-> 부서번호 20, 30이 각각의 값으로 바뀌고 출력되었다.



EX) 세 개의 칼럼명이 모두 같은 DEPT, DEPT_tEMP 테이블을 NATURAL [INNER] JOIN으로 수행한다.

```SQL
SELECT *
FROM DEPT NATURAL INNER JOIN DEPT_TEMP;

-- INNER는 DEFAULT 옵셥으로 아래와 같이 생략 가능하므로 위 SQL과 아래 SQL은 같은 결과를 얻을 수 있다.

SELECT *
FROM DEPT NATURAL JOIN DEPT_TEMP;
```

-> DNAME의 내용이 바뀐 부서번호 20, 30의 데이터는 실행 결과에서 제외된 것을 알 수 있다.



EX) 다음에는 같은 조건이지만 출력 칼럼에서 차이가 나는 일반적인 INNER JOIN을 수행한다.

```SQL
SELECT *
FROM DEPT JOIN DEPT_TEMP
ON DEPT.DEPTNO = DEPT_TEMP.DEPTNO
AND DEPT.DNAME = DEPT_TEMP.DNAME
AND DEPT.LOC = DEPT_TEMP.LOC;

-- 위 SQL과 아래 SQL은 같은 결과를 얻을 수 있다.

SELECT *
FROM DEPT, DEPT_TEMP
WHERE DEPT.DEPTNO = DEPT_TEMP.DEPTNO
AND DEPT.DNAME = DEPT_TEMP.DNAME
AND DEPT.LOC = DEPT_TEMP.LOC;

-- 바뀌지 않은 것들만 출력
```

```
    DEPTNO DNAME                        LOC                            DEPTNO
---------- ---------------------------- -------------------------- ----------
DNAME                        LOC
---------------------------- --------------------------
        10 ACCOUNTING                   NEW YORK                           10
ACCOUNTING                   NEW YORK

        40 OPERATIONS                   BOSTON                             40
OPERATIONS                   BOSTON

```

-> 내용이 바뀐 내용은 결과에서 제외되었다. <u>차이가 나는 부분은 NATURAL JOIN은 JOIN에 사용된 같은 이름의 칼럼을 하나로 처리하지만 INNER JOIN의 경우는 2개의 칼럼으로 표시된다.</u>



#### 5. USING 조건절 (원하는 컬럼만 선택해서 EQUI JOIN 가능)

NATURAL JOIN에서는 모든 일치되는 컬럼에 대해 JOIN이 이루어지지만, <u>FROM 절의 USING 조건절을 이용하면 같은 이름을 가진 칼럼들 중에서 원하는 칼럼에 대해서만 선택적으로 EQUI JOIN을 할 수가 있다.</u>

이 기능은 SQL SERVER에서는 지원하지 않는다.



EX) 세 개의 칼럼명이 모두 같은 DEPT와 DEPT_TEMP 테이블을 DEPTNO 칼럼을 이용한 [INNER] JOIN의 USING 조건절로 수행한다.

```SQL
SELECT *
FROM DEPT JOIN DEPT_TEMP
USING (DEPTNO);
```

```
    DEPTNO DNAME                        LOC
---------- ---------------------------- --------------------------
DNAME                        LOC
---------------------------- --------------------------
        10 ACCOUNTING                   NEW YORK
ACCOUNTING                   NEW YORK

        20 RESEARCH                     DALLAS
r                            DALLAS

        30 SALES                        CHICAGO
MARKETING                    CHICAGO


    DEPTNO DNAME                        LOC
---------- ---------------------------- --------------------------
DNAME                        LOC
---------------------------- --------------------------
        40 OPERATIONS                   BOSTON
OPERATIONS                   BOSTON

```

위의 SQL의 * 와일드카드처럼 별도의 칼럼 순서를 지정하지 않으면 USING 조건절의 기준이 되는 칼럼이 다른 칼럼보다 먼저 출력된다. (EX. DEPTNO가 첫 번째 칼럼이 된다.)

<u>이때 USING JOIN은 JOIN에 사용된 같은 이름의 칼럼을 하나로 처리한다.</u>

-> DEPTNO 두 개 X



EX) <u>USING 조건절을 이용한 EQUI JOIN에서도 NATURAL JOIN과 마찬가지로 JOIN 칼럼에 대해서는 ALIAS나 테이블 이름과 같은 접두사를 붙일 수 없다. (DEPT.DEPTNO -> DEPTNO)</u>

```SQL
-- ERROR : USING 절의 열 부분은 식별자로 가질 수 없음
-- DEPT.DEPTNO 문제

SELECT DEPT.DEPTNO, DEPT.DNAME, DEPT.LOC, DEPT_TEMP.DNAME, DEPT_TEMP.LOC
FROM DEPT JOIN DEPT_TEMP
USING (DEPTNO);

-- 올바른 사례

SELECT DEPTNO, DEPT.DNAME, DEPT.LOC, DEPT_TEMP.DNAME, DEPT_TEMP.LOC
FROM DEPT JOIN DEPT_TEMP
USING (DEPTNO);
```

```
    DEPTNO DNAME                        LOC
---------- ---------------------------- --------------------------
DNAME                        LOC
---------------------------- --------------------------
        10 ACCOUNTING                   NEW YORK
ACCOUNTING                   NEW YORK

        20 RESEARCH                     DALLAS
r                            DALLAS

        30 SALES                        CHICAGO
MARKETING                    CHICAGO


    DEPTNO DNAME                        LOC
---------- ---------------------------- --------------------------
DNAME                        LOC
---------------------------- --------------------------
        40 OPERATIONS                   BOSTON
OPERATIONS                   BOSTON

```



EX) DEPT와 DEPT_TEMP 테이블의 일부 데이터 내용이 변경되었던 DNAME을 조인 조건으로 [INNER] JOIN의 USING 조건절을 수행한다.

```SQL
SELECT *
FROM DEPT JOIN DEPT_TEMP
USING (DNAME);
```

```
DNAME                            DEPTNO LOC                            DEPTNO
---------------------------- ---------- -------------------------- ----------
LOC
--------------------------
ACCOUNTING                           10 NEW YORK                           10
NEW YORK

OPERATIONS                           40 BOSTON                             40
BOSTON
```

바뀐 20, 30은 결과에서 제외되었다.

그리고 USING에 사용된 DNAME이 첫 번째 칼럼으로 출력된 것과 함께, JOIN 조건에 참여하지 않은 DEPTNO와 LOC가 2개의 칼럼으로 표시된 것을 알 수 있다.

-> DNAME 두 개 X



EX) 세 개의 칼럼명이 모두 같은 DEPT와 DEPT_TEMP 테이블을 LOC와 DEPTNO 2개 칼럼을 이용한 [INNER] JOIN의 USING 조건절로 수행한다.

```SQL
SELECT *
FROM DEPT JOIN DEPT_TEMP
USING (LOC, DEPTNO);
```

```
LOC                            DEPTNO DNAME
-------------------------- ---------- ----------------------------
DNAME
----------------------------
NEW YORK                           10 ACCOUNTING
ACCOUNTING

DALLAS                             20 RESEARCH
r

CHICAGO                            30 SALES
MARKETING


LOC                            DEPTNO DNAME
-------------------------- ---------- ----------------------------
DNAME
----------------------------
BOSTON                             40 OPERATIONS
OPERATIONS
```

USING에 사용된 LOC, DEPTNO가 첫 번째, 두 번째 칼럼으로 출력되고, JOIN 조건에 참여하지 않은 DNAME 칼럼은 2개의 칼럼으로 표시되었다.

-> LOC, DEPTNO 두 개 X



EX) DEPTNO, DNAME 2개의 칼럼을 이용한 [INNER] JOIN의 USING 조건절로 수행한다.

```SQL
SELECT *
FROM DEPT JOIN DEPT_TEMP
USING (DEPTNO, DNAME);
```

```
    DEPTNO DNAME                        LOC
---------- ---------------------------- --------------------------
LOC
--------------------------
        10 ACCOUNTING                   NEW YORK
NEW YORK

        40 OPERATIONS                   BOSTON
BOSTON
```

DEPTNO과 DNAME이 같은 컬럼만이므로 20, 30은 제외된다.

또한 DEPTNO, DNAME이 먼저 나오고, USING에 참여되지 않은 LOC은 두 개 출력된다.



#### 6. ON 조건절 (더 폭 넓게 쓸 수 있다.)

<u>JOIN 서술부(ON 조건절)와 비 JOIN 서술부(WHERE 조건절)를 분리해 이해가 쉬우며, 칼럼명이 다르더라도 JOIN 조건을 사용할 수 있는 장점이 있다.</u>



EX) 사원 테이블과 부서 테이블에서 사원 번호와 사원 이름, 소속부서 코드, 소속부서 이름을 출력한다.

```SQL
SELECT E.EMPNO, E.ENAME, E.DEPTNO, D.DNAME
FROM EMP E JOIN DEPT D
ON (E.DEPTNO = D.DEPTNO);
```

```
     EMPNO ENAME                    DEPTNO DNAME
---------- -------------------- ---------- ----------------------------
      7369 SMITH                        20 RESEARCH
      7499 ALLEN                        30 SALES
      7521 WARD                         30 SALES
      7566 JONES                        20 RESEARCH
      7654 MARTIN                       30 SALES
      7698 BLAKE                        30 SALES
      7782 CLARK                        10 ACCOUNTING
      7788 SCOTT                        20 RESEARCH
      7839 KING                         10 ACCOUNTING
      7844 TURNER                       30 SALES
      7876 ADAMS                        20 RESEARCH

     EMPNO ENAME                    DEPTNO DNAME
---------- -------------------- ---------- ----------------------------
      7900 JAMES                        30 SALES
      7902 FORD                         20 RESEARCH
      7934 MILLER                       10 ACCOUNTING
```

<u>NATURAL JOIN의 JOIN 조건은 기본적으로 같은 이름을 가진 모든 칼럼들에 대한 동등 조건이지만, 임의의 JOIN 조건을 지정하거나, 이름이 다른 칼럼명을 JOIN 조건으로 사용하거나, JOIN 칼럼을 명시하기 위해서는 ON 조건절을 사용한다.</u>

ON 조건절에 사용된 괄호는 옵션 사항이다.

<u>USING 조건절을 이용한 JOIN에서는 JOIN 칼럼에 대해서 ALIAS나 테이블 명 같은 접두사를 사용하면 에러가 나지만 반대로 ON 조건절을 사용한 JOIN의 경우 ALIAS나 테이블 명과 같은 접두사를 사용해 SELECT에 사용되는 칼럼을 논리적으로 명확하게 지정해주어야 한다.</u>

##### USING => ALIAS X

##### ON => ALIAS O

ON 조건절은 WHERE 절의 JOIN 조건과 같은 기능을 하면서도, 명시적으로 JOIN 조건을 구분할 수 있으므로 가장 많이 사용된다. 다만, FROM 절에 테이블이 많이 사용될 경우 가독성이 떨어지는 단점이 있다.



##### 1. WHERE 절과의 혼용

EX) ON 조건절과 WHERE 검색 조건은 충돌 없이 사용할 수 있다.

부서코드 30인 부서의 소속 사원 이름 및 소속 부서 코드, 부서 코드, 부서 이름을 찾아본다.

```SQL
SELECT E.ENAME, E.DEPTNO, D.DEPTNO, D.DNAME
FROM EMP E JOIN DEPT D
ON E.DEPTNO = D.DEPTNO
WHERE E.DEPTNO = 30;
```

```
ENAME                    DEPTNO     DEPTNO DNAME
-------------------- ---------- ---------- ----------------------------
ALLEN                        30         30 SALES
WARD                         30         30 SALES
MARTIN                       30         30 SALES
BLAKE                        30         30 SALES
TURNER                       30         30 SALES
JAMES                        30         30 SALES
```

DEPTNO 두 개



##### 2. ON 조건절 + 데이터 검증 조건 추가

ON 조건절에 JOIN 조건 외에도 데이터 검색 조건을 추가할 수 있으나, 검색 조건 목적인 경우 WHERE 절을 사용할 것을 권고한다.

다만, 아우터 조인에서 조인의 대상을 제한하기 위한 목적으로 사용되는 추가 조건의 경우 ON에 표기되어야 한다.

EX) 매니저 사원 번호가 7698번인 사원들의 이름 및 소속부서 코드, 부서 이름 찾아본다.

```SQL
SELECT E.ENAME, E.MGR, D.DEPTNO, D.DNAME
FROM EMP E JOIN DEPT D
ON E.DEPTNO = D.DEPTNO
AND E.MGR = 7698;
```

```
ENAME                       MGR     DEPTNO DNAME
-------------------- ---------- ---------- ----------------------------
JAMES                      7698         30 SALES
TURNER                     7698         30 SALES
MARTIN                     7698         30 SALES
WARD                       7698         30 SALES
ALLEN                      7698         30 SALES
```



##### 3. ON 조건절 예제

EX) 팀과 스타디움 테이블을 스타디움ID로 JOIN해서 팀이름, 스타디움ID, 스타디움 이름을 찾아본다.

```SQL
SELECT TEAM_NAME, TEAM.STADIUM_ID, STADIUM_NAME
FROM TEAM JOIN STADIUM
ON TEAM.STADIUM_ID = STADIUM.STADIUM_ID
ORDER BY STADIUM_ID;

-- 위는 STADIUM_ID라는 공통된 칼럼이 있기 때문에 USING 조건절로도 구현할 수 있다.

SELECT TEAM_NAME, STADIUM_ID, STADIUM_NAME
FROM TEAM JOIN STADIUM
USING (STADIUM_ID)
ORDER BY STADIUM_ID;

-- + 고전적인 WHERE 절의 INNER JOIN

SELECT TEAM_NAME, TEAM.STADIUM_ID, STADIUM_NAME
FROM TEAM, STADIUM
WHERE TEAM.STADIUM_ID = STADIUM.STADIUM_ID
ORDER BY STADIUM_ID;
```

```
TEAM_NAME
--------------------------------------------------------------------------------
STADIU
------
STADIUM_NAME
--------------------------------------------------------------------------------
광주상무
A02
광주월드컵경기장

강원FC
A03
강릉종합경기장
```



EX) 팀과 스타디움 테이블을 팀ID로 JOIN해 팀이름, 팀ID, 스타디움 이름을 찾아본다. STADIUM에는 팀ID가 HOMETEAM_ID 칼럼으로 표기되어 있다.

```SQL
SELECT TEAM_NAME, TEAM_ID, STADIUM_NAME
FROM TEAM JOIN STADIUM
ON TEAM.TEAM_ID = STADIUM.HOMETEAM_ID
ORDER BY TEAM_ID;

-- WHERE 절의 INNER JOIN으로도 구현 가능

SELECT TEAM_NAME, TEAM_ID, STADIUM_NAME
FROM TEAM, STADIUM
WHERE TEAM.TEAM_ID = STADIUM.HOMETEAM_ID
ORDER BY TEAM_ID;
```

```
TEAM_NAME
--------------------------------------------------------------------------------
TEAM_I
------
STADIUM_NAME
--------------------------------------------------------------------------------
울산현대
K01
울산문수경기장

삼성블루윙즈
K02
수원월드컵경기장

TEAM_NAME
--------------------------------------------------------------------------------
TEAM_I
------
STADIUM_NAME
--------------------------------------------------------------------------------

스틸러스
K03
포항스틸야드

유나이티드
K04
```



##### 4. 다중 테이블 JOIN

EX) 사원과 DEPT 테이블의 소속 부서명, DEPT_TEMP 테이블의 바뀐 부서명 정보를 출력한다.

```SQL
-- 명시적

SELECT E.EMPNO, D.DEPTNO, D.DNAME, T.DNAME New_DNAME
FROM EMP E JOIN DEPT D
ON (E.DEPTNO = D.DEPTNO)
JOIN DEPT_TEMP T
ON (E.DEPTNO = T.DEPTNO);

-- WHERE 절의 INNER JOIN으로 구현 가능
-- 암시적

SELECT E.EMPNO, D.DEPTNO, D.DNAME, T.DNAME New_DNAME
FROM EMP E, DEPT D, DEPT_TEMP T
WHERE E.DEPTNO = D.DEPTNO
AND E.DEPTNO = T.DEPTNO;
```

```
     EMPNO     DEPTNO DNAME                        NEW_DNAME
---------- ---------- ---------------------------- ----------------------------
      7934         10 ACCOUNTING                   ACCOUNTING
      7839         10 ACCOUNTING                   ACCOUNTING
      7782         10 ACCOUNTING                   ACCOUNTING
      7902         20 RESEARCH                     r
      7876         20 RESEARCH                     r
      7788         20 RESEARCH                     r
      7566         20 RESEARCH                     r
      7369         20 RESEARCH                     r
      7900         30 SALES                        MARKETING
      7844         30 SALES                        MARKETING
      7698         30 SALES                        MARKETING

     EMPNO     DEPTNO DNAME                        NEW_DNAME
---------- ---------- ---------------------------- ----------------------------
      7654         30 SALES                        MARKETING
      7521         30 SALES                        MARKETING
      7499         30 SALES                        MARKETING
```



EX) GK 포지션의 선수별 연고지명, 팀명, 구장명을 출력한다.

```SQL
SELECT P.PLAYER_NAME 선수명, P.POSITION 포지션, T.REGION_NAME 연고지명, T.TEAM_NAME 팀명, S.STADIUM_NAME 구장명
FROM PLAYER P JOIN TEAM T
ON P.TEAM_ID = T.TEAM_ID
JOIN STADIUM S
ON T.STADIUM_ID = S.STADIUM_ID
WHERE P.POSITION = 'GK'
ORDER BY 선수명;

-- WHERE절 INNER JOIN

SELECT P.PLAYER_NAME 선수명, P.POSITION 포지션, T.REGION_NAME 연고지명, T.TEAM_NAME 팀명, S.STADIUM_NAME 구장명
FROM PLAYER P, TEAM T, STADIUM S
WHERE P.TEAM_ID = T.TEAM_ID
AND T.STADIUM_ID = S.STADIUM_ID
AND P.POSITION = 'GK'
ORDER BY 선수명;
```

```
선수명                                   포지션               연고지명
---------------------------------------- -------------------- ----------------
팀명
--------------------------------------------------------------------------------
구장명
--------------------------------------------------------------------------------
강성일                                   GK                   대전
시티즌
대전월드컵경기장

권정혁                                   GK                   울산
울산현대
울산문수경기장
```



EX) 홈팀이 3점 차이 이상으로 승리한 경기의 경기장 이름, 경기 일정, 홈팀 이름과 원정팀 이름 정보를 출력한다.

```SQL
SELECT ST.STADIUM_NAME, SC.STADIUM_ID, SCHE_DATE, HT.TEAM_NAME, AT.TEAM_NAME, HOME_SCORE, AWAY_SCORE
FROM SCHEDULE SC JOIN STADIUM ST
ON SC.STADIUM_ID = ST.STADIUM_ID
JOIN TEAM HT
ON SC.HOMETEAM_ID = HT.TEAM_ID
JOIN TEAM AT
ON SC.AWAYTEAM_ID = AT.TEAM_ID
WHERE HOME_SCORE >= AWAY_SCORE + 3;

-- WHERE절의 INNER JOIN

SELECT ST.STADIUM_NAME, SC.STADIUM_ID, SCHE_DATE, HT.TEAM_NAME, AT.TEAM_NAME, HOME_SCORE, AWAY_SCORE
FROM SCHEDULE SC, STADIUM ST, TEAM HT, TEAM AT
WHERE HOME_SCORE >= AWAY_SCORE + 3
AND SC.HOMETEAM_ID = HT.TEAM_ID
AND SC.AWAYTEAM_ID = AT.TEAM_ID
AND SC.STADIUM_ID = ST.STADIUM_ID;

-- FROM 절에 4개의 테이블이 조인에 참여, HOME TEAM과 AWAY TEAM의 팀 이름을 구하기 위해 TEAM 테이블을 HT와 AT 두 개의 ALIAS로 구분했다.
```

```
STADIUM_NAME
--------------------------------------------------------------------------------
STADIU SCHE_DATE
------ ----------------
TEAM_NAME
--------------------------------------------------------------------------------
TEAM_NAME
--------------------------------------------------------------------------------
HOME_SCORE AWAY_SCORE
---------- ----------
성남종합운동장
B02    20120317
일화천마

STADIUM_NAME
--------------------------------------------------------------------------------
STADIU SCHE_DATE
------ ----------------
TEAM_NAME
--------------------------------------------------------------------------------
TEAM_NAME
--------------------------------------------------------------------------------
HOME_SCORE AWAY_SCORE
---------- ----------
유나이티드
         6          0
```

