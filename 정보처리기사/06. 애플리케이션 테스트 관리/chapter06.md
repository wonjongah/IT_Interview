##### 소프트웨어 테스트의 기본 7원칙

| 원칙                                      | 설명                                                         |
| ----------------------------------------- | ------------------------------------------------------------ |
| 테스팅은 결함이 존재함을 밝히는 활동이다. | 테스팅은 소프트웨어의 잠재적인 결함을 줄일 수 있지만, 결함이 발견되지 않아도 결함이 없다고 증명할 수 없음을 나타낸다. |
| 완벽한 테스팅은 불가능하다.               | 무한 경로, 무한 입력 값, 무한 시간이 소요되어 완벽하게 테스트할 수 없으므로 리스크 분석과 우선순위를 토대로 테스트에 집중할 것을 의미한다. |
| 테스팅은 개발 초기에 시작해야 한다        | 애플리케이션의 개발 단계에 테스트를 계획하고 SDLC의 각 단계에 맞춰 전략적으로 접근하는 것을 고려하라는 뜻이다. |
| 결합 집중                                 | 애플리케이션 결함의 대부분은 소수의 특정한 모듈에 집중되어 존재한다는 의미이다. (파레토 법칙) |
| 살충제 패러독스                           | 동일한 테스트 케이스로 반복 실행하면 결함을 발견할 수 없으므로 주기적으로 테스트 케이스를 리뷰하고 개선해야 한다. |
| 테스팅은 정황(Context)에 의존한다.        | 정황과 비즈니스 도메인에 따라 테스트를 다르게 수행해야 한다. |
| 오류-부재의 궤변                          | 사용자의 요구사항을 만족하지 못하면 오류를 발견하고 그 오류를 제거했다고 해도, 해당 애플리케이션의 품질이 높다고 말할 수 없다. 즉 사용자 요구와 기대에 만족하지 못해 사용성이 현저히 낮다면 결함을 찾는 과정은 아무 소용이 없다는 의미이다. |



##### 테스트와 디버깅

| 구분     | 테스트                                        | 디버깅                                                 |
| -------- | --------------------------------------------- | ------------------------------------------------------ |
| 목적     | 알려지지 않은 에러 발견                       | 이미 알고 있는 에러의 수정                             |
| 수행     | 시스템 내부 관련자, 테스트 팀 등 외부의 제3자 | 시스템 내부 관련자                                     |
| 주요작업 | 에러의 발견                                   | 에러의 정확한 위치 파악, 에러의 타입 식별, 에러의 수정 |



##### 테스트 절차

- 테스트 계획
  1. 테스트 목적과 범위 정의
  2. 대상 시스템 구조 파악
  3. 테스트 일정 정의
  4. 종료조건 정의
  5. 조직/비용산정
- 테스트 분석 및 디자인
  1. 목적 및 원천 정의
  2. 요구사항 분석
  3. 리스크분석 및 우선순위결정
  4. 테스트 데이터 준비
  5. 테스트 환경 및 도구 준비
- 테스트케이스 및 시나리오 작성
  1. 테스트케이스 작성
  2. 테스트용 스크립트 작성
  3. 테스트케이스 검토
  4. 테스트 시나리오 작성
- 테스트 수행
  1. 초기 데이터 적재
  2. 테스트 수행
  3. 결함 리포팅
- 테스트 결과 평가 및 리포팅
  1. 테스트 결과 정리
  2. 테스트 프로세스 리뷰
  3. 테스트 결과 평가
  4. 테스트 리포팅



##### 테스트 수행 시 발생하는 산출물

- 테스트 계획서
  - 테스트 목적과 범위, 대상 시스템 구조 파악, 테스트 수행 절차, 테스트 일정, 조직의 역할 및 책임 정의, 종료 조건 정의 등 테스트 수행을 계획한 문서
- 테스트 케이스
  - 테스트를 위한 설계 산출물로, 응용 소프트웨어가 사용자의 요구사항을 준수하였는지 확인하기 위해 설계된 입력값, 실행 조건, 기대 결과로 구성된 테스트 항목의 명세서
- 테스트 시나리오
  - 테스트 수행을 위한 여러 개의 테스트 케이스의 집합으로 테스트 케이스의 동작 순서를 기술한 문서이며, 테스트를 위한 절차를 명세한 문서이다.
- 테스트 결과서
  - 테스트 결과를 정리한 문서로 테스트 프로세스를 리뷰하고, 테스트 결과를 평가하고 리포팅하는 문서이다.



##### 테스트 케이스

- 일정한 조건 하에서 요구사항의 만족 여부를 확인하기 위해 만들어진 테스트 전의 입력 값과 테스트 후의 기댓값의 집합이다.
- 다양한 비즈니스 수행 형태를 정보시스템이 제대로 구현했는가를 검증하기 위해 만든 입력값과 예상 결과 값의 조화이다.
- 비즈니스 수행 커버리지 측정 도구로 사용하기 위해 테스트 전의 입력값과 테스트 후의 기댓값들의 집합이다.
- 측정 가능한 상태에 대한 정보, 조건, 이벤트, 입/출력 값을 포함하는 데이터로 구성한다.



##### 정적 테스트

- 프로그램 실행 없이 소스 코드의 구조를 분석하여 논리적으로 검증하는 테스트 기법이다.
- 세부 유형으로는 인스펙션, 코드 검사, 워크스루가 있다.



##### 동적 테스트

- 프로그램의 실행을 요구하는 테스트 기법이다.
- 세부 유형으로는 화이트박스 테스트와 블랙박스 테스트가 있다.



##### V-Model 기반 테스트

- 소프트웨어 개발생명주기의 각 단계에 맞춰 전략적으로 테스트를 수행하는 활동
- 사용자 환경 -> 시스템 정의 -> 요구분석 -> 구조 설계 -> 상세 설계 -> 코딩 -> 디버깅 -> 단위시험 -> 통합 시험 -> 시스템시험 -> 인수시험 -> 설치 시험



##### 그레이박스 테스트

소프트웨어 내부 구조의 일부만 알고 수행하는 테스트로 블랙박스 시험과 화이트 박스 시험이 혼합된 방식의 시험 형태이다.



##### 블랙박스 테스트

프로그램 내부의 구조와는 관계없이 외부에 제공하는 기능 중심으로 모든 기능들이 정상적으로 수행되는지 확인한다.



##### 화이트박스 테스트

프로그램의 내부 로직을 보면서 테스트를 수행하는 테스트 기법이다.



##### 명세 기반 기법, 구조 기반 기법

| 구분 | 명세 기반 기법                                               | 구조 기반 기법                                               |
| ---- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 개념 | 주어진 명세를 바탕으로 테스트케이스를 도출하며 표현 방식은 UML을 많이 사용함. | 소프트웨어나 시스템의 구조를 중심으로 테스트케이스를 도출. 특정 커버리지를 달성하기 위한 테스트를 설계하고, 케이스를 도출하기 위해 사용되는 기법. |
| 특징 | 블랙 박스 기법. 문서 분석 필요. 기능적/비기능적 테스트케이스 도출 | 화이트 박스 기법. 컴포넌트/시스템 코드 분석. 추가적 테스트케이스 도출. |
| 종류 | 동등분할, 경계값분석, 결정테이블, 상태전이, 유스케이스       | 구문커버리지, 결정커버리지, 조건커버리지, 조건/결정커버리지, 변경조건/결정커버리지, 다중조건커버리지 |



##### 경험 기반 테스트

- 이전에 테스터가 다루었던 유사 어플리케이션이나 기술에서의 겸험, 직관, 테스트의 기술 능력으로부터 테스트 케이스를 추출하는 기법.
- 테스트 케이스 작성 시간을 줄이고 테스터 역량을 충분히 발휘하여 명세 불충분하고 시간 제약시 효과적인 테스트 기법이다.
- 테스트 경험에 따라 효과가 다르기 때문에 일관성이 떨어지는 단점이 있다.

| 기법            | 설명                                                         |
| --------------- | ------------------------------------------------------------ |
| 탐색점 기법     | 테스트 차터를 기반으로 정해진 시간 내에 테스트 설계, 수행 등을 동시에 진행하는 Heuristics Testing 접근법. 테스트 케이스 작성 시간을 최소화하고 테스터의 지적 능력을 최대한 활용하여 테스트 수행에 집중 |
| 오류 추정 기법  | 가능한 결함을 나열하고 결함이나 오류를 추정에 의해 검출 및 수정 |
| 체크리스트 기법 | 테스트하고 평가해야 할 내용과 경험을 분류해 나열해놓은 체크리스트를 기반으로 테스트 수행 |
| 분류 트리 기법  | 구조로 분석, 표현하고 테스트 케이스를 도출하는 기법. 블랙박스 형태로 테스트하며 명세가 없을 때도 사용 가능한 비공식적 기법의 한 가지 |



##### 화이트 박스 테스트 기법 유형

| 유형                    | 설명                                                         |
| ----------------------- | ------------------------------------------------------------ |
| 기본 경로               | Tom McCabe가 제안한 대표적인 화이트 박스 테스트 기법. 순환복잡도를 통해 독립적인 경로의 수를 찾아 테스트하는 기법 |
| 반복경로 검사(루프검사) | 프로그램의 반복 구조에 초점을 맞추어 검사                    |
| 제어 구문 검사          | 프로그램의 제어구문(if, case, else)를 테스트하는 기법        |
| 데이터 흐름 검사        | 프로그램에서 변수의 정의와 변수 사용의 위치에 초점을 맞추어 검사 |



##### 기본 경로 테스팅 테스트 케이스 추출 단계

1. 테스팅할 대상의 플로우 그래프를 그린다.

- 플로우 그래프
  - 프로그램 내부구조의 제어흐름을 그래프로 표현하여 구조를 파악하고 시험 경로를 추출하기 위해 표현
  - 입력에서 출력에 이르기짜기의 프로그램 내부구조를 플로우 그래프로 표현

2. 순환복잡도를 계싼한다.

- 순환복잡도를 통해 전체 프로그램의 내부구조를 시험할 수 있는 독립적인 경로의 수를 계산
- 순환복잡도 공식

```
V(G) = E - N + 2
V(G) = R
V(G) = P + 1
V(G) : 순환복잡도, E : 엣지의 수, N : 노드의 수, R :화살표와 노드로 둘러싸인 구역, P : 분기수
```

3. 독립적인 경로들을 정의한다.

- 순환복잡도를 통해 계산된 횟수를 기반으로 독립적인 경로들을 정리

4. 정의된 각 경로의 테스트 케이스를 작성한다.

- 정의된 각 경로를 시험할 테스트 케이스를 작성



##### 테스트 커버리지

- 시스템/소프트웨어 구조가 테스트 스위트에 의해 테스트된 정도 또는 소프트웨어의 소스 코드가 얼마만큼 테스트가 되었는가를 나타내는 지표를 의미한다.
- 소프트웨어의 유형에 따라 컴포넌트 레벨 커버리지, 통합 레벨 구조 커버리지, 시스템 레벨 구조 커버리지로 나뉠 수 있다.
- 컴포넌트 레벨 커버리지 : 구문/조건/결정 커버리지 측정.
- 통합 레벨 커버리지 : 2개 이상의 컴포넌트 사이의 호출 관계가 얼마나 테스트 되었는지 측정한다.
- 시스템 레벨 구조 커버리지 : 사용자 입장에서의 프로세스을 기준으로 시스템을 구성하는 각 프로세스들이 얼마나 테스트 되었는지 측정한다.



##### 테스트 커버리지 유형

- 시스템/소프트웨어 구조가 테스트 스위트에 의해 테스트된 정도 또는 소프트웨어의 소스코드가 얼마만큼 테스트가 되었는가를 나타내는 지표를 의미한다.
- 소프트웨어의 유형에 따라 컴포넌트 레벨 커버리지, 통합 레벨 구조 커버리지, 시스템 레벨 구조 커버리지로 나뉠 수 있다.
- 컴포넌트 레벨 커버리지 : 구문/조건/결정 커버리지 측정.
- 통합 레벨 구조 커버리지 : 2개 이상의 컴포넌트(하위단꼐 포함) 사이의 호출 관계가 얼마나 테스트 되었는지 측정한다.
- 시스템 레벨 구조 커버리지 : 사용자 입장에서의 프로세스을 기준으로 시스템을 구성하는 각 프로세스들이 얼마나 테스트되었는지 특정한다.

| 커버리지 유형           | 설명                                                         |
| ----------------------- | ------------------------------------------------------------ |
| 구문 커버리지           | 프로그램 내 모든 명령문을 적어도 한번 수행                   |
| 결정 커버리지           | 프로그램 내 전체 결정문이 적어도 한번은 참과 거짓의 결과를 수행 |
| 조건 커버리지           | 결정 명령문 내 각 조건이 적어도 한번은 참과 거짓의 결과가 출력되도록 수행 |
| 조건/결정 커버리지      | 전체 조건식 뿐 아니라 개별 조건식도 참, 거짓이 한번씩 결과가 되도록 수행 |
| 변경 조건/결정 커버리지 | 각 개별 조건식이 다른 개별 조건식에 영향을 받지 않고 전체 조건식의 독립적 영향을 주도록 수행 |
| 다중 조건 커버리지      | 결정 포인트 내 있는 모든 개별식 조건의 모든 조합을 고려한 커버리지 |



##### 구문 커버리지 

- 프로그램을 구성하는 문장들이 최소한 한번은 실행될 수 있는 입력 값을 테스트 케이스로 선정하는 테스트 케이스 설계 방법.
- 즉, <u>프로그램 내 모든 명령문을 적어도 한번만 수행</u>하면 된다.



##### 구문 커버리지

- 프로그램에 있는 분기를 최소한 한번은 실행하게 하는 테스팅하는 방법.
- 즉, 프로그램 내 <u>전체 결정문</u>이 <u>적어도 한번은 참과 거짓의 결과</u>를 수행하도록 테스트 케이스를 설계해야 한다.



##### 조건 커버리지

- &&, || 등의 조건을 가진 분기문이 전체 조건식의 결과와 관계없이 &&나 || 전후의 각 개별 조건식이 참 한 번, 거짓 한 번을 갖도록 테스트 케이스를 만드는 방법이다.
- 즉, 결정 명령문 내 각 <u>조건</u>이 <u>적어도 한번은 참과 거짓</u>의 결과가 출력되도록 수행하는 테스트 케이스를 생성하는 방법이다.



##### MC/DC (Modified Condition / Decision Coverage)

- 각 개별 조건식이 다른 개별 조건식에 영향을 받지 않고 전체 조건식의 독립적 영향을 주도록 수행하는 방법.
- 전체 조합을 테스트하는 것은 현실적으로 불가능하기 때문에 가능한 의미있게 조합 수를 줄여 테스트하는 것이 MC/DC 커버리지의 핵심 개념이다.

- 전체 조건식 테이블 작성 -> 개별 조건식(A, B)에 따른 T, F 그뒤 전체조건식(A조건식B)의 결과(T or F)
- <u>전체 조건식에 독립적 영향을 주지 않는 테스트 케이스 제외</u>. (A, B 둘 중 하나가 바뀌면 전체 결과가 바뀌지 않는 테스트 케이스 제외)
- 제외한 테스트 케이스 이외의 테스트 케이스 완성!
- 테스트 케이스 수를 줄일 수 있다.



##### 다중조건 (Multiple Condition)

- 결정 포인트 내 있는 <u>모든 개별 식 조건의 모든 조합</u>을 고려한 커버리지이다.
- 100%를 달성하기 위해서는 모든 개별 조건식 조합을 실행해야 하기 때문에 다른 커버리지에 비해 상대적으로 많은 테스트케이스가 필요.



##### 에러, 오류

- 결함의 원인이 되는 것을 의미.
- 사람에 의해 생성된 실수가 대표적인 케이스이다.



##### 결함(Defect), 결점(Fault), 버그(Bug)

- 에러가 원인이 되어 제품에 포함된 결함이다.
- 제거하지 않으면 실패 또는 문제의 원인.



##### 실패(Failure), 문제(Problem)

- 제품의 결함이 있는 부분이 실행될 때 발생되는 현상이다.



##### 블랙박스 테스트 기법 유형

| 유형                          | 설명                                                         |
| ----------------------------- | ------------------------------------------------------------ |
| 동등분할 기법, 동치 분할 검사 | 입력값의 범위를 유사한 특징을 갑는 동등 <u>그룹</u>으로 나누고, 각 그룹마다 <u>대표 값</u>을 선정하여 테스트케이스를 선정하는 기법. |
| 경계값 분석 기법              | 경계값 분석은 등가 분할된 <u>경계의 유효한 값</u>과 <u>경계에서 가장 가까운 유효하지 않는 값</u>을 테스트 데이터로 선택하여 컴포넌트나 시스템을 테스트하는 기법. |
| 원인 효과 그래프 기법         | <u>입력값을 원인으로, 효과를 출력값</u>으로 정하고 이에 따른 <u>원인 결과 그래프</u>를 만들어서 테스트 케이스를 작성하는 기법 |
| 의사결정테이블 테스팅 기법    | 생성될 수 있는 결과를 테이블로 나열하여 가능한 <u>모든 조합</u>을 테스트하는 기법 |



##### 도메인 테스트

입력 변수들 간에 상관관계가 존재하는 경우 그 관계에 따라 영역을 분할하고 테스트케이스를 도출하는 방법. 블랙박스 테스트이다.

- 구성요소

| 구성요소   | 설명                                                         |
| ---------- | ------------------------------------------------------------ |
| ON 포인트  | 경계에 있는 값                                               |
| OFF 포인트 | 경계에 있지 않은 경계에 가까운 값(ON포인트에 가까운 값). 경계가 <=, >=, = 등에 의해 닫힌 경우 영역 밖의 경계에 가까운 값. 경계가 <, > 등에 의해 개발된 경우 영역 안의 경계에 가까운 값 |
| IN 포인트  | 경계에 있지 않은(ON 포인트가 아닌) 경계조건을 만족하는 값    |
| OUT 포인트 | 경계에 있지 않은(ON 포인트가 아닌) 경계조건을 만족하지 않는 값 |



##### 인수 테스트

사용자 요구분석 명세서에 명시된 사항을 모두 충족하는지 판정하고 시스템이 예상대로 동작하고 있는지 점검하는 테스트 단계이다.

- 인수 테스트 유형

| 인수테스트  | 설명                                                         |
| ----------- | ------------------------------------------------------------ |
| 알파테스트  | 개발자의 장소에서 사용자가 개발자 앞에서 행해지며, 오류와 사용상의 문제점을 사용자와 개발자가 함께 확인하면서 검사하는 기법(개발자 환경에서 테스트) |
| 베타 테스트 | 다수의 사용자를 제한되지 않은 환경에서 프로그램을 사용하게 하고 오류가 발견되면 개발자에게 통보하는 방식(사용자 환경에서 테스트) |

- 인수테스트
  - 알파테스트 (개발자 환경, 사용자와 개발자 함께)
  - 베타테스트 (사용자 환경, 개발자에게 통보)



##### 테스팅은 정황(Context)에 의존한다.

- 테스팅은 정황에 따라 다르게 진행되어야 한다. 예를 들어, 안전 최우선 소프트웨어를 테스트하는 경우 전자 상거래 사이트를 테스트할 때와는 다른 방식으로 진행해야 한다.
- 이때 정황과 도메인에 따라 다르게 테스팅을 진행해야 하지만 아래와 같이 모든 테스팅에서 변하지 않는 사항도 존재하낟. 이러한 부분을 고려해서 테스트 시 계획 및 수행이 필요하다.

1. 테스트 주요 활용에 대한 테스트 프로젝트 계획
2. 표준적인 기법 적용
3. 독립적인 테스트 환경
4. 효율적/효과적 테스트 팀 조직
5. 정식 리포팅



##### 테스트 레벨에 따른 테스트의 유형

확인(validation) - 단(단위) 통(통합) 시(시스템) 인(인수) 설(설치)

| 테스트        | 설명                                                         |
| ------------- | ------------------------------------------------------------ |
| 단위 테스트   | 구현된 단위 모듈의 기능 수행 여부를 판정하고 내부에 존재하는 논리적 오류를 검출한다. |
| 통합 테스트   | 모듈 간의 인터페이스 연계를 검증하고 오류를 확인, 모듈 간의 상호 작용 및 연계 동작이 제대로 기능하는지 점검한다. |
| 시스템 테스트 | 단위, 통합 테스트 후 전체 시스템이 정상적으로 작동하는지 판정하는 기능을 점검한다. |
| 인수 테스트   | 사용자 요구분석 명세서에 명시된 사항을 모두 충족하는지 판정하고 시스템이 예쌍대로 동작하고 있는지 점검한다. |



##### 하향식 통합 방법

메인 제어 모듈(프로그램)로부터 아래방향으로 제어의 경로를 따라 하향식으로 통합하면서 테스트 진행하며, 메인 제어 모듈에 통합되는 하위 모듈과 최하위 모듈은 '깊이-우선' 또는 '너비-우선' 방식으로 통합된다.

- <u>하향식 통합 방법</u>
  - 1단계 : 메인 제어 모듈은 작성된 프로그램을 사용하고, 아직 작성되지 않은 하위 제어 모듈 및 모든 하위 컴포넌트를 대신하여 더미 모듈인 스텁을 개발한다.
  - 2단계 : 깊이-우선 또는 너비-우선 방식에 따라, 하위 모듈인 스텁이 한번에 하나씩 실제 모듈로 대체된다.
  - 3단계 : 각 모듈 또는 컴포넌트를 통합하면서 테스트 수행
  - 4단계 : 테스트가 완료되면 스텁이 실제 모듈 또는 컴포넌트로 작성된다.



##### 스텁(stub)

<u>특정 시스템 컴포넌트의 개발이 완료되지 않은 상황</u>에서도 필요한 시험을 진행하기 위해 생성된 <u>더미 컴포넌트</u>를 의미하며, 단지 기능 또는 프로시저 헤더 등의 코드 루틴만 갖고 내부 프로세싱은 제한적으로 존재하지 않는 것이 일반적이다. <u>루틴으로부터 반환값이 요구된다면 테스트 스텁은 다른 컴포넌트들의 시험을 위해 특정값을 되돌려준다.</u>



##### 상향식 통합 방법

애플리케이션 구조에서 최하위 레벨의 모듈 또는 컴포넌트로부터 위쪽 방향으로 제어의 경로를 따라 이동하면서 구축과 테스트 진행

- 상향식 통합 방법 수행 단계
  - 1단계 : 최하위 레벨의 모듈 또는 컴포넌트들이 하위 모듈의 기능을 수행하는 클러스터로 결합된다.
  - 2단계 : 상위의 모듈에서 데이터의 입력과 출력을 확인하기 위한 더미 모듈인 드라이버 작성.
  - 3단계 : 각 통합된 클러스터 단위를 테스트한다.
  - 4단계 : 테스트가 완료되면 각 클러스터들은 프로그램의 위쪽으로 결합되며, 드라이버는 실제 모듈 또는 컴포넌트로 대체된다.



##### 드라이버(Driver)

시스템 및 시스템 컴포넌트를 시험하는 환경의 일부분으로 시험을 지원하는 목적 하에 생성된 코드와 데이터이다. 테스트 하네스와 같은 의미로 사용되나 테스트 드라이버는 일반적으로 상향식 테스트에서 아직 통합되지 않은 상위 컴포넌트의 동작을 시뮬레이션하는 모의 모듈을 의미한다. 이런 의미에서 테스트 드라이버를 테스트 하네스의 일종으로 보기도 한다. 단순히 시험을 위한 사용자 인터페이스를 제공하거나, 정교하게 제작된 경우, 코드가 변경되었을 때도 항상 같은 결과를 제공하여 시험을 자동화시킬 수 있도록 디자인되어 있다.



##### 하향식 - stub, 상향식 - cluster, driver



##### 회귀 테스트

회귀 테스트는 테스트를 완료한 컴포넌트가 어떠한 변화로 인해 의도하지 않은 오류가 생기지 않았음을 보증하기 위해 기존의 테스트 케이스로 다시 테스트하는 것을 말한다.

- 회귀 테스트 케이스 선정 기준
  - 실제 수정이 발생한 컴포넌트와 관련된 테스트 케이스를 도출한다. 이를 위해 변경 관리 도구를 사용해 애플리케이션 변경 영향도 분석을 한다.
  - 변경 영향도가 가장 높은 컴포넌트 기능에 집중한 회귀 테스트 케이스를 도출한다.



##### 테스트 오라클

테스트의 결과가 참인지 거짓인지를 판단하기 위해서 사전에 정의된 참 값을 입려가여 비교하는 기법 및 활동을 말한다.

- 테스트 오라클의 유형
  - 참 오라클 : 모든 입력값에 대하여 기대하는 결과를 생성함으로써 발생된 오류를 모두 검출할 수 있는 오라클이다.
  - 샘플링 오라클 : 특정한 몇 개의 입력값에 대해서만 기대하는 결과를 제공해주는 오라클이다.
  - 휴리스틱 오라클 : 샘플링 오라클을 개선한 오라클로, 특정 입력값에 대해 올바른 결과를 제공하고, 나머지 값들에 대해서는 휴리스틱(추정)으로 처리하는 오라클
  - 일관성 검사 오라클 : 애플리케이션 변경이 있을 때, 수행 전과 후의 결과 값이 동일한지 확인하는 오라클



##### 애플리케이션 성능 측정 요소

| 스케줄링 기준   | 설명                                                         | 목표   |
| --------------- | ------------------------------------------------------------ | ------ |
| 처리량          | 주어진 시간에 최대한 많은 작업 처리(<u>**처리된 프로세스 수 / 시간**</u>) | 최대화 |
| 경과(반환) 시간 | 전체작업 수행시간을 최소화(system in -> system out 시간)     | 최소화 |
| 대기 시간       | 준비 큐에서 기다리는 시간 최소화                             | 최소화 |
| 응답 시간       | 애플리케이션에 요청을 전달한 시간부터 응답이 도착할 때까지 걸린 시간 | 최소화 |
| 자원 사용률     | 단위 시간당 작업을 수행하는 총 시간 비율                     | 최대화 |
| Fairness        | 프로세스별 자원할당의 공정성                                 | 최대화 |
| Deadline        | 실시간 환경 등에서의 즉시 처리 한계 시간                     | 최대화 |



##### 정적 분석 도구

- 정적 분석 도구는 만들어진 애플리케이션을 <u>실행하지 않고 분석</u>하는 방법.
- 대부분의 경우 소스 코드에 대한 코딩 표준, 코딩 스타일, 코드 복잡도 및 남은 결함을 발견하기 위해 사용한다.
- 테스트를 수행하는 사람이 작성된 소스코드에 대한 이해를 바탕으로 도구를 이용해서 분석하는 것을 말한다.

**정적 분석 도구 유형**

| 유형             | 설명                                              |
| ---------------- | ------------------------------------------------- |
| 구조 검사 도구   | 소프트웨어 내부 구조를 검사할 수 있는 도구        |
| 데이터 분석 도구 | 소프트웨어 내부 데이터 흐름을 분석할 수 있는 도구 |
| 순서 검사 도구   | 소프트웨어의 실행 순서를 분석할 수 있는 도구      |



##### 코드 리팩토링

나쁜 코드(중복 코드, 긴 메소드, 거대 클래스) -> 코드리팩토링 -> 클린 코드(가독성 향상, 의존성 최소화, 중복 최소화)

- 외부 동작을 바꾸지 않으면서 내부 구조를 개선하는 방법으로 소프트웨어 시스템을 변경하는 프로세스를 의미
- 겉으로 보이는 소프트웨어의 기능을 변경하지 않으면서 소프트웨어를 보다 이해하기 쉽고 수정하기 쉽도록 만드는 기법

##### 코드 리팩토링 기법 유형

| 유형             | 설명                                                         |
| ---------------- | ------------------------------------------------------------ |
| 메소드 정리      | 메소드를 새로 정의하거나 사용하지 않는 메소드를 삭제하는 리팩토링 기법이다. |
| 객체간 기능 이동 | 메서드, 필드, 클래스를 새로 생성 및 이동하는 리팩도링 기법이다. |
| 데이터 구성      | 필드나 객체의 데이터 변환으로 가독성을 향상시키는 리팩토링 기법 |
| 조건문 단순화    | 복잡한 조건문을 단순화하여 가독성 및 중복을 최소화하는 리팩토링 기법 |
| 일반화           | 필드나 메서드를 자주 사용하는 클래스로 이동시키는 리팩토링 기법. |



##### 나쁜 코드, 클린 코드

- 나쁜 코드
  - 다른 개발자가 로직을 이해하기 어렵게 작성된 코드. 대표적 사례로 처리 로직의 제어가 정제되지 않고 서로 얽혀 있는 스파게티 코드, 변수나 메서드에 대한 이름 정의를 알 수 없는 코드, 동일한 처리 로직이 중복되게 작성된 코드
- 클린 코드
  - 잘 작성되어 가독성이 높고, 단순하며, 의존성을 줄이고, 중복을 최소화하여 깔끔하게 잘 정리된 코드



##### 메소드 정리 기법 유형

- inline method 
  - 메서드의 몸체가 메서드의 이름만 명확할 때, 호출하는 곳에 메서드 몸체를 넣고 메서드 삭제.
- Extract method 
  - 그룹으로 함께 묶을 수 있는 코드 조각이 있으면, 코드 목적이 잘 드러나도록 메서드의 이름을 지어 별도의 메소드로 뽑아낸다.
- Extract class 
  - 두 개의 클래스가 해야 할 일을 하나의 클래스가 하고 있는 경우, 새로운 클래스를 만들고 관련된 필드와 메서드를 이전 클래스에서 새로운 클래스로 옮긴다.
- Parameterize method
  - 몇몇 메서드가 메서드 몸체에 다른 값을 포함하고 있는 것을 제외하고는 비슷한 일을 하고 있다면, 다른 값을 파라메터로 넘겨 받는 하나의 메서드를 만든다.



##### 객체 간 기능 이동 기법 유형

- Move method 
  - 메서드가 자신이 정의된 클래스보다 다른 클래스의 기능을 더 많이 사용하고 있다면, 이 메서드를 가장 많이 사용하고 있는 클래스에 비슷한 몸체를 가진 새로운 메서드를 만들고 이전 메서드는 간단한 위임으로 바꾸거나 완전히 제거하는 방법
- Move field
  - 필드가 자신이 정의한 클래스보다 다른 클래스에서 더 많이 사용되고 있다면, 타겟 클래스에 새로운 필드를 만들고 기존 필드를 사용하고 있는 모든 부분을 변경하는 기법
- Extract Class
  - 두 개의 클래스가 해야 할 일을 하나의 클래스가 하고 있는 경우, 새로운 클래스를 만들고 관련 있는 필드와 메서드를 이전 클래스에서 새로운 클래스로 옮기는 기법.

