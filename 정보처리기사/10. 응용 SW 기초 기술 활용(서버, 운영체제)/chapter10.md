##### 레지스터

<u>처리 중인 데이터나 처리 결과를 임시 보관하는 기능</u>을 하며 <u>산술 연산이나 정보 해석, 전송등을 할 수 있는 일정 길이의 정보를 저장하는 CPU 내부의 초고속 기억장치</u>



##### 레지스터의 종류

| 종류                         | 상세설명                                                     |
| ---------------------------- | ------------------------------------------------------------ |
| PC(PROGRAM COUNTER)          | 다음에 인출할 명령어의 주소를 가지고 있는 레지스터           |
| MAR(MEMORY ADDRESS REGISTER) | 메모리 주소를 일시적으로 저장하는 레지스터                   |
| MBR(MEMORY BUFFER REGISTER)  | 기억장치에 쓰여질 데이터 혹은 기억장치로부터 읽혀진 데이터를 일시적으로 저장하는 버퍼 레지스터 |
| IR(INSTRUCTION REGISTER)     | 가장 최근에 인출된 명령어 코드가 저장되어 있는 레지스터      |
| AC(ACCUMULATOR)              | 데이터나 연산결과를 일시적으로 저장하는 레지스터             |



##### 레지스터 동작 절차

- 명령어 인출과정에서 MAR이 지시하는 주기억장치의 주소 번지에서 데이터를 읽어와서 MBR에 저장한다.
- 저장 과정에서는 MAR에 저장되어 있는 주소 번지에 해당하는 주기억장치 위치에 MBR에 저장되어 있는 데이터를 저장한다.



##### 인터럽트

프로그램 실행 중 CPU의 현재 처리 순서를 중단시키고 다른 동작을 수행하도록 요구하는 시스템 동작



##### 인터럽트 발생원인

- 기계적인 문제(정전, 데이터 전달 과정에서 하드웨어 오류 발생)
- 프로그램 상의 문제
- 컴퓨터 조작자의 의도적인 조작에 의한 중단
- 입출력 장치들의 동작에 CPU의 기능이 요청되는 경우
- 산술 연산 오버 플로우, 언어플로우 발생



##### 인터럽트 유형

- 외부 인터럽트(하드웨어 인터럽트)
  - 전원 이상 
    - 정전 또는 전원 이상에 의한 인터럽트 발생
  - 기계 착오
    - CPU의 기능적인 오류 동작 발생
  - 외부 신호
    - 타이머에 의한 규정된 시간을 알리는 경우
    - 키보드로 인터럽트 발생
    - 외부 장치로부터 인터럽트 요청 발생
  - 입/출력
    - 입출력 데이터의 오류나 이상 현상이 발생한 경우
    - 입출력 장치가 데이터의 전송을 요구 또는 전송 완료 알림
- 내부 인터럽트(하드웨어 인터럽트)
  - 프로그램 검사
    - 0으로 나누기
    - 오버 플로우, 언어플로우
    - 부당한 기억장소 참조와 같은 프로그램 상 오류
- 소프트웨어 인터럽트
  - SVC 명령
    - 사용자가 SVC 명령을 써서 의도적으로 발생한다.
    - 기억장치 할당 및 오퍼레이터와의 통신이 필요한 경우



##### 인터럽트 처리 루틴

- 인터럽트가 발생하면, 인터럽트를 받은 장치는 현재 자신의 상태를 PCB라는 자료구조에 기억시켜두고 인터럽트를 처리한다.
- 인터럽트 처리루틴(IPR)을 수행한 후, 인터럽트 처리 시 보존시켰던 상태를 제어상태 레지스터에 복구한다.

인터럽트 인지 -> 현재 상태 보존 -> 요청 인터럽트 서비스로 분기 및 서비스 -> 사용자 상태 복구 및 재개



##### 명령어 수행 과정(INSTRUCTION CYCLE)

- 명령어 사이클은 인출 - 해독 - 실행 - 저장의 순서이다.
- Fetch한 명령어의 operand가 간접주소일 경우 : Indirect Cycle
- Fetch한 명령어의 operand가 직접주소인 경우 : Execute Cycle

<u>명령어 인출 -> 명령어 해독 -> 명령어 실행 -> 데이터 저장</u>



##### 프로세스의 주 상태 종류

- 인출(Fetch Cycle)
  - 주기억장치로부터 수행할 명령어를 cpu로 가져오는 단계
  - 명령어의 operand가 간접주소일 경우 : Indirect Cycle
  - 명령어의 operand가 직접주소인 경우 : Execute Cycle
- 간접(indirect Cycle)
  - 명령어의 operand가 간접주소 지정이 된 경우 유효 주소를 계산하기 위해 주기억장치에 접근하는 단계
- 실행(Execute Cycle)
  - 명령의 코드를 해독결과에 따라 필요한 연산들을 수행
- 인터럽트(Interrupt Cycle)
  - 인터럽트 발생 시 인터럽트 처리를 하고 완료되면 Fetch로 진행



##### Locality(구역성, 지역성, 국부성, 국소성)

- 프로그램의 어느 한 특정 부분만 한동안 집중적으로 참조하는 현상
- 메모리 계층구조나 데이터베이스의 LRU 알고리즘은 구역성 특징을 활용해 성능을 향상시킨 사례이다.

| 기법        | 내용                                                         | 사례                        |
| ----------- | ------------------------------------------------------------ | --------------------------- |
| 시간 구역성 | 최근에 액세스된 프로그램이나 데이터가 가까운 미래에 다시 액세스 될 가능성이 높다. | loop, subroutine            |
| 공간 구역성 | 기억장치 내 인접하여 저장된 데이터들이 연속적으로 액세스 될 가능성이 높다 | array, table, 순차코드 실행 |
| 순차 구역성 | 분기하지 않는 한, 명령어들은 기억장치에 저장된 순서대로 인출되어 실행된다. | 구조적 프로그래밍           |



##### 인터럽트 우선순위

- 소프트웨어 방식(**폴링**)
  - CPU가 모든 I/O 제어기들에 접속된 선 이용, 인터럽트를 요구한 장치를 검사하는 방식
  - Test I/O 신호를 이용해 각 I/O 장치의 인터럽트 플래그 세트되어 있는지 검사
  - 검사 순서가 우선 순위를 결정
  - 장점
    - 소프트웨어 수정을 통해 우선순위 변경이 쉽다.
    - 회로가 간단하고 융통성이 있으며 별도의 하드웨어 불필요
  - 단점
    - 많은 인터럽트가 있을 경우 그것들을 모두 조사하는데 많은 시간이 걸려 처리시간이 오래 걸린다.
- 하드웨어 방식
  - **직렬연결**
    - **Daisy-Chain(데이지 체인)**
    - 우선순위 부여 방식으로 인터럽트가 발생하는 모든 장치를 한 개의 회선에 직렬로 연결(CPU로 발생되는 INTA 출력선을 I/O 제어기들에 직렬로 접속하는 방식)
    - 우선순위가 높은 장치를 선두에 위치시키고 나머지를 우선순위에 따라 차례로 연결한다.
    - 인터럽트를 요구한 I/O 장치는 Ain 입력을 받는 즉시 자신의 고유번호, 인터럽트 벡터를 벡터 버스를 통해 CPU로 전송한다.
    - 인터럽트 벡터는 해당 I/O 장치를 위한 인터럽트 서비스 루틴의 시작 주소를 결정한다.
  - 장점
    - 하드웨어 구조가 간단하다.
  - 단점
    - 우선순위 낮은 장치들이 서비스를 받지 못하는 현상이 발생한다.
  - **병렬연결**
    - **Mutiple Interrupt**
    - 각 I/O 제어기와 CPU 사이에 인터럽트 요구선과 인터럽트 확인 선을 접속하는 방식
    - 인터럽트가 발생하는 각 장치를 개별적인 회선으로 연결한다.
    - 각 장치의 회선에 대응하는 Mask Register를 사용하고 우선순위는 Mask Register의 비트 위치에 의해 결정한다.
  - 장점
    - cpu가 인터럽트를 요구한 장치식별이 용이하다.
  - 단점
    - 입력 핀의 수에 의해 제한한다.



##### DMA(Direct Memory Access)

- <u>입출력 장치 제어기가 CPU에 의한 프로그램의 실행 없이 자료의 이동을 하는 방식</u>
- <u>입출력 속도 향상이 가능하며, CPU와 주변 장치간의 속도 차를 줄일 수 있다.</u>
- DMA 제어기가 자료 전송 종료 후, 입출력 장치가 DMA를 요구하면 CPU가 CPU 사이클이 끝나는 지점마다 메인메모리의 제어를 허용한다.



##### Isolated I/O (I/O Mapped I/O)

- IN, OUT 명령에 의해 주어진 I/O 포트에 입출력 기기가 접속되어 입출력을 수행
- 입/출력 명령이 각각 인터페이스 레지스터 주소를 가진다.



##### Interrupt I/O

- 데이터 전송을 마이크로컴퓨터의 인터럽트 기능을 가진 하드웨어에 의해서 제어하는 방식
- 입출력 기기의 동작 완료를 인터럽트 신호로써 입출력 기기에서 CPU로 보내면, CPU가 인터럽트 신호를 확인한 다음 현재 실행 중인 프로그램을 중단하고 입출력 기기와 데이터 전송을 수행하는 방식이다.



##### 시스템 소프트웨어의 종류와 각 기능

| 시스템 소프트웨어         | 개념                                                         |
| ------------------------- | ------------------------------------------------------------ |
| 운영체제                  | 하드웨어와 소프트웨어 자원을 관리하고 컴퓨터 프로그램을 위한 공통 서비스를 제공하는 프로그램 |
| 어셈블러                  | 어셈블리어를 기계어로 변환해주는 프로그램                    |
| 컴파일러 또는 언어 번역기 | 고급 언어로 작성한 원시 프로그램을 기계어인 목적 프로그램으로 바꾸어 주는 프로그램 |
| 인터프리터                | 고급 언어나 코드화된 중간 언어를 입력받아 목적 프로그램 생성 없이 직접 기계어를 생성하여 실행해주는 프로그램 |
| 전처리기                  | 원시 프로그램을 번역하기 전에 미리 언어의 기능을 확장한 원시 프로그램을 생성하는 시스템 프로그램 ex) #include |
| 링커                      | 서로 독립적으로 작성되고 번역된 목적 프로그램을 호출 및 연계시키는 시스템 프로그램 |
| 로더                      | 실행 Code를 주기억장치에 적재해 실행 가능하도록 해주는 시스템 프로그램 |



##### 로더의 단계별 동작

<u>할당 -> 링킹 -> 재배치 -> 적재</u>

- 할당 (프로그램 수행에 필요한 기억장소를 할당 받는 기능)
  - 프로그램의 일부에 대한 기억장치를 할당 후 실행 시 필요한 부분만을 기억장치에 할당
- 링킹 (실행중인 여러 프로그램이 라이브러리나 특정 모듈을 공유 가능하도록 프로그램에 적재 시에 링크하는 기능)
  - 링킹 로더는 링커에 의해 제공된 목적파일의 재배치 정보를 통해 실행 가능한 코드를 만들어 주기억장치에 적재한다.
- 재배치 (프로그램 내 재배치 가능한 상대주소를 할당된 메모리의 절대주소로 변환하는 기능)
  - 목적 코드의 각 명령에 대해 재배치 여부를 명시하는 재배치 비트를 추가해 표시한다.
- 적재 (할당, 링킹, 재배치 작업이 수행된 프로그램을 주기억장치에 적재하는 기능)
  - 로더의 할당 방법에 의거, 필요한 기능을 수행한다.

로더는 할당, 링킹, 재배치, 적재를 통해 프로그램을 주기억장치에 적재한다.



##### 로더의 종류

- 컴파일 즉시 로더
  - 가장 간단한 방법
  - 번역기가 로더의 역할까지 담당
  - 로더의 기능은 단순히 실행을 제어
  - 어셈블러의 재번역 요구
  - 서로 다른 언어로 작성된 모듈 간 연결 불가
- 절대 로더
  - 출력 결과는 보조 기억장치에 저장
  - 기계어 코드 프로그램에서 미리 지정한 번지에 프로그램과 데이터를 직접 적재
  - 프로그래머가 어셈블러에게 적재주소 지정
- 재배치 로더
  - 적재 모듈을 주기억장치에 적재
  - 상대주소를 절대주소로 변환
  - 로드 과정에서 메모리의 적당한 영역을 찾아 로드
- 링킹 로더
  - 재배치 링크 및 적재를 한꺼번에 수행
  - 두 단계의 패스로 구성
- 동적 로더
  - 재배치 로더와 링킹 로더의 단점 보안
  - CPU가 현재 사용 중인 부분만 로드
  - 미사용 중인 프로그램은 보조기억장치에 저장해두는 방식
  - 서브루틴들의 상호 호출 관계 파악
  - load-on-call이라고도 한다.



##### 유닉스 명령어

- chmod
  - 파일이나 디렉토리의 접근 권한을 변경하는 명령어
  - read, write, execute 권한을 추가 또는 제거한다.
- du
  - 현재 디렉토리 아래의 디스크 사용현환을 출력한다.
- fork
  - fork() 함수는 현재 프로세스에 대해 자식 프로세스를 생성하는 함수
- cat
  - cat 파일명을 통해 파일의 내용을 보는 명령어



##### 접근 권한 유형

|      | owner(소유자) |      |      | group |      |      | other |      |
| ---- | ------------- | ---- | ---- | ----- | ---- | ---- | ----- | ---- |
| r    | w             | x    | r    | w     | x    | r    | w     | x    |
| 4    | 2             | 1    | 4    | 2     | 1    | 4    | 2     | 1    |

- Read(r)
  - 일반 파일 : 읽기와 복사 가능
  - 디렉토리 : 디렉토리의 내용 표시 가능
- Write(r)
  - 일반 파일 : 수정 기능
  - 디렉토리 : 파일의 추가와 삭제 기능
- Execute(x)
  - 일반 파일 : 수행 가능
  - 디렉토리 : 티렉토리의 변경 가능

ex)

```java
chmod 777 test.txt
// test.txt 파일을 파일의 owner, group, other 모두에게 읽기, 쓰기, 실행권한을 모두 부여

chmod 700 test.txt
// test.txt 파일을 파일의 owner에게만 읽기, 쓰기, 실행 권한 부여

chmod 750 test.txt
// test.txt 파일을 파일의 owner에게만 읽기, 쓰기, 실행 권한 부여, group에게는 읽기, 실행 권한을 부여
```



##### 리눅스/유닉스 운영체제의 기본 명령어

| 분류               | 명령어                            |
| ------------------ | --------------------------------- |
| 사용자             | #id, #last, #who 등               |
| 파일 처리          | #ls, #pwd, #rm, #cp, #mv, #tar 등 |
| 프로세스           | #ps, #pmap, #kill pid 등          |
| 파일 permission    | #chmod, #chown 등                 |
| 네트워크           | #ifconfig, #dig, #host 등         |
| 인스톨             | #yum, #rpm 등                     |
| 검색               | #grep, #find, #locate 등          |
| 디렉토리 이동/생성 | #cd, #mkdir 등                    |



```java
$ chmod 755 text1
$ ls -l text1
-rwxr-xr-x 1 vian class1 0 JUN 15 17:34 text1
```



##### 유닉스 기본 명령어

- ls
  - 디렉토리와 파일 목록을 출력하는 명령어
  - -a, -all 옵션은 상세정보 표시 옵션
  - -l 옵션은 긴 리스트의 Format으로 출력하는 옵션
- cat
  - cat [파일명]을 통해 파일의 내용을 출력하는 명령어
- cd
  - cd [디렉토리경로] 지정한 디렉토리로 이동하는 명령어
  - cd . 현재 디렉토리로 이동
  - cd .. 상위 디렉토리로 이동
  - cd / 가장 상위 디렉토리로 이동
- cp
  - 파일을 지정한 경로에 복사하는 명령어
  - cp [옵션] 원본파일 복사할 파일
  - -f, -force 복사 대상 파일이 있으면 강제로 지우고 복사
  - -i, -interactive 복사 대상 파일이 있으면 사용자에게 복사 여부 확인



##### 쉘(Shell)

- 쉘이란 컴퓨터 내부를 관리하는 <u>Kernel과 사용자 간의 인터페이스를 담당</u>한다.
- 쉘은 세션 별 변수 설정 등 사용자 지정 상태로 사용자가 요청한 명령어를 해석한다.
- 리눅스와 유닉스 명령어는 콘 쉘, 본 쉘, 배시 쉘 등 다양한 쉘이 있으며, 쉘 스크립트를 입력하는 에디터는 vi나 이맥스를 사용하며, GUI 에디터인 지에디터를 사용할 수 있다.
- 백그라운드 처리 및 서브 쉘 생성이 가능하며, 일련의 명령어를 묶어 처리하는 스크립트 기능 지원
- 운영 체제는 프로세스, 기억장치, 인/출력 관리를 수행한다.



##### 파이프라인 기법

<u>단위 시간 내에 하나 이상의 명령어를 병렬처리함으로써 Performance를 향상시키는 멀티프로세스 환경에서 명령어 처리 메카니즘</u>

- 명령어 처리 과정을 여러 단계로 세분화

- 단계마다 다른 작업을 중첩/수행해 병렬성을 높인다.



##### 파이프라인 기법의 분류

| 유형                              | 설명                                                         |
| --------------------------------- | ------------------------------------------------------------ |
| 단일 Pipeline                     | 명령어 수행과정에서 각 단계를 <u>한번만 중첩해</u> 다수의 동작을 동시에 수행하는 병렬처리 기술 |
| Super Pipeline                    | 하나의 <u>Pipeline을 여러 부분으로 나누어 연속적인 흐름 과정으로 처리, 성능을 향상시키는 병렬처리 기술. Pipeline을 더욱 세분화하여 수행시간을 단축. 각 명령어 수행단계를 두 개 이상으로 분할한 구조</u> |
| Super Scalar                      | 프로세서 내에 <u>Pipeline된 ALU를 여러개 포함해 매 사이클마다 다수의 명령어들을 동시에 실행하는 병렬처리 기술</u>. ex) 1개의 cycle에 정수연산 2개, 실수연산 4개 동시 수행 |
| Super Pipelined Super Scalar      | 슈퍼스칼라 기법에 슈퍼 파이프라이닝 기법 적용. 수행 시간을 더 단축한 기법 |
| VLIW(very long instruction world) | 동시에 수행될 수 있는 명령어들을 컴파일러 수준에서 추출, <u>하나의 명령어로 압축</u>해 수행하는 병렬처리 기술. EPIC 기법 : 컴파일러가 소스 코드로부터 명시적 병렬성을 찾아 병렬처리가 가능하도록 기계어 코드 생성, 병렬 수행 된다. FI, DI는 한 회로에서 수행된다. EI만 여러 개의 기능 UNIT에 분할 수행 |



##### Flynn의 컴퓨터 시스템 분류 제안

Flynn은 <u>컴퓨터 명령어와 데이터의 흐름 개수에 따라 단일명령어/단일명령어 흐름(SSID), 단일명령어/다중 데이터 흐름(SIMD), 다중 명령어 / 단일 데이터 흐름(MISD), 다중명령어 / 다중 데이터 흐름(MIMD)으로 분류</u>한다.



##### 병렬처리와 분산처리 비교

- 병렬처리는 프로세서 자체를 멀티코어로 병렬화하거나, 여러 개의 프로세스를 이용하여 다수의 작업을 고속으로 처리 가능하다.
- 연산장치를 병렬로 구성한 처리 구조로 벡터 계산이나 행렬 계산에 주로 사용되는 Array 프로세서나 벡터 프로세서, 여러 개의 명령어를 동시 수행하는 파이프라인 기법 등이 있다.

| 구분 | 병렬처리                                  | 분산처리                                                     |
| ---- | ----------------------------------------- | ------------------------------------------------------------ |
| 정의 | 프로세서를 늘려 다수의 작업을 동시에 처리 | 컴퓨터를 네트워크로 상호 연결하여 전체적인 일의 일부를 분산하여 처리 |
| 구성 | 다수의 프로세서와 하나의 메모리로 구성    | 다수의 프로세서와 메모리, 리소스로 구성                      |



##### 운영체제 유형별 특징

| 유형                                    | 개념                                                         |
| --------------------------------------- | ------------------------------------------------------------ |
| 다중 프로그래밍 시스템(멀티 프로그래밍) | CPU의 효율을 극대화하기 위해 여러 개의 프로그램이 마치 동시에 실행되는 것처럼 처리하는 방식, 메모리 관리 필요 |
| 시분할 시스템                           | <u>프로세서 스케줄링</u>과 <u>다중 프로그래밍</u>을 사용해 각 사용자에게 컴퓨터를 시간적으로 분할 사용 |
| 분산 처리 시스템                        | 시스템마다 운영체제와 메모리를 가지고 독립적으로 운영되며 필요할 때 <u>통신</u>하는 시스템 |
| 다중 처리 시스템                        | 마이크로 프로세서 여러 개를 연결해 다중 프로세서를 생성. CPU 여러 장을 두고 각각 업무를 분담하여 처리한다. |
| 일괄 처리 시스템                        | 일정량의 데이터를 모아서 한꺼번에 일괄 처리하는 방식         |
| 실시간 처리 시스템                      | 데이터에 대한 처리 요구 발생 시 즉시 처리 응답               |



##### 위상에 따른 분산 컴퓨팅 구조 분류

분산처리 시스템 내의 노드들은 여러 가지 물리적 방법으로 연결될 수 있는데, 이러한 물리적인 연결형태를 위상이라고 한다.

| 구분                | 설명                                                         |
| ------------------- | ------------------------------------------------------------ |
| 완전 연결 구조      | 각 노드가 시스템 내의 모든 다른 노드와 직접 연결, 기본 비용은 노드 숫자의 제곱에 비례, 메시 네트워크 구조라고도 한다. |
| 부분 연결 구조      | 모든 노드 쌍에 대해서 직접 연결이 존재하는 형태가 아니다. 비용은 완전 연결 네트워크보다 낮다. 통신 속도가 늦다. 완전 연결 네트워크보다 신뢰성이 떨어진다. |
| 계층 구조           | 각 사이트들은 트리 형태로 구성, 형제 중의 하나가 다른 형제에게 메시지를 전달하려면 부모까지 올라가서 형제에게로 다시 내려간다. |
| 성형 구조           | 중심 노드는 타 노드와 연결, 타 노드는 상호간 연결되지 않는 방식. 비용은 노드 수에 비례하나 일반적으로 통신비용은 낮다. 중심 노드에서 병목현상이 발생한다. |
| 환형 구조(Ring)     | 단방향, 양방향 통신 방법 존재. 기본비용은 노드 수에 비례한다. 단일연결, 이중연결 방식 존재. |
| 다중 접근 버스 구조 | 공유되는 하나의 버스가 존재한다. 비용은 노드 수에 비례하며, 버스 회선이 고장나면 네티워크가 분할된다.  직선 버스, 환영 버스 유형 존재. |



##### FIFO 알고리즘

메모리에 올라온 지 가장 오래된 페이지를 교체하는 메모리 교체 알고리즘



##### 페이지 결함

- 기억장치에 적재되지 않은 Page를 사용하는 현상
- 콜드 미스 : 데이터를 최초로 읽을 때 발생
- 용량 미스 : 메모리 용량이 부족해서 발생





##### 페이징 기법

- <u>가상기억장치 내의 프로그램과 데이터를 고정되게 분할한 용량(페이지)을 주기억장치에 사상시키는 기법</u>
- 프로그램의 실제 주소와 주기억장치 주소가 다르므로 PMT(Page Map Table) 필요
- 외부 단편화 해결 가능, 내부 단편화 발생



##### 세그먼테이션 기법

- 가상기억장치 내의 프로그램과 데이터를 각 세그먼트가 주기억장치에 적재될 때마다 필요한 서로 다른 크기의 세그먼트로 분할
- 매핑 테이블(세그먼트 번호 : 주소 + 크기) 유지



##### 페이징과 세그먼테이션 기법 비교

| 항목     | 페이징                                                  | 세그먼테이션                                                 |
| -------- | ------------------------------------------------------- | ------------------------------------------------------------ |
| 할당단위 | 고정                                                    | 가변                                                         |
| 적재단위 | 프로그램 일부 적재                                      | 프로그램 전체 적재                                           |
| 장점     | 외부 단편화가 없음. 교체 시간 짧다.                     | 코드, 데이터 공유가 용이. 내부단편화가 최소화.               |
| 단점     | Thrasing 문제 심각. 내부단편화 코드나 데이터 공유 논란. | 외부단현화 발생. 주기억장치가 커야 한다. 교체시간이 길어진다. |



##### 가상 메모리 / 가상 기억장치(VM)

- 주기억장치 안의 프로그램 양이 많아질 때 사용하지 않는 프로그램을 보조기억장치 안의 특별한 영역으로 옮겨서, 그 보조기억장치 부분을 주기억장치처럼 사용할 수 있는 영역.
- 당장 실행할 프로그램만 주기억장치로 이동



##### 가상메모리 관리 정책

| 관리정책  | 내용                                                         | 기법                           |
| --------- | ------------------------------------------------------------ | ------------------------------ |
| 할당 정책 | 각 프로세스에게 할당할 메모리의 크기를 관리. 실행 중 주기억장치 할당량 변화 알고리즘 | 고정 할당 기법, 가변 할당 기법 |
| 호출 정책 | 언제 어느 항목들을 보조기억장치에서 주기억장치에 가져올 것인지 결정 | 요구호출 기법, 예측호출 기법   |
| 배치 정책 | 프로그램의 한 블록을 주기억장치의 어디에 배치할 것인가 관리  | First Fit, Best Fit, Worst Fit |
| 교체 정책 | 주기억장치에 적재할 공간이 없을 경우, 무엇과 교체할 것인가에 대한 관리 | FIFO, LRU, LFU, NUR            |



##### 워킹세트

하나의 프로세스에 자주 참조되는 페이지를 모아놓은 기법



##### 스래싱 방지 기법

| 기법               | 내용                                                         | 특징                                                         |
| ------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 프리페이징         | 과도한 페이지 부재를 줄이기 위해 모든 페이지를 한 번에 페이지 프레임에 적재하는 기법 | 페이지 적재 과다                                             |
| 워킹세트           | 하나의 프로세스에 자주 참조되는 페이지를 모아놓은 기법으로 그 집합에 속하지 않은 페이지를 교체 | 스래싱 방지                                                  |
| 페이지 프레임 조정 | 현재 페이지 부재와 바로 전 페이지 부재 사이의 시간을 관찰해 그 시간이 지금까지 최소시간보다 크면 그 사이에 호출되지 않았던 페이지들을 모두 제거하는 기법 | PFF가 높으면 메모리의 페이지 적재 영역의 크기를 증가, 낮으면 줄인다. |



##### 메모리 인터리빙 기법

- <u>기억 장치 모듈에 순차적인 접근을 함으로서 접근시간을 최소화하고 성능을 향상</u>
- 메모리를 복수 개의 모듈(뱅크)로 나누고 각 모듈에 연속적인 주소를 부여하여 동시에 접근이 가능하게 하는 기법



##### 메모리 인터리빙의 종류

- 상위 인터리빙
  - 프로그램과 데이터들이 <u>독립적이어서</u> 각각의 기억모듈에 저장하는 것이 더 효과적인 다중 프로그래밍에 사용
- 하위 인터리빙
  - 연속된 주소가 연속된 다수의 모듈에 <u>동시 동작</u>하며, 단점은 확장이 어렵고 어느 한 모듈의 오류가 전체에 영향을 미친다.
- 혼합 인터리빙
  - 기억장치 모듈을 뱅크로 그룹화하고 각 그룹 내에서 하위 인터리빙하는 방식



##### 페이지 교체 알고리즘

| 구분                 | 내용                                                         | 특징                                                         |
| -------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 무작위 페이지 교체   | 특별한 사용자에게 차이를 두지 않고 교체하는 기법. 교체할 페이지를 무작위로 선정 | 오버헤드가 적은 기법. 바로 뒤에 참조될 페이지도 교체 가능    |
| FIFO/선입 선출       | 메모리에 올라온 지 <u>가장 오래된 페이지를 교체</u>          | FIFO 이상현상 발생 : FIFO 기법 하에 프로세스에 더 많은 페이지를 할당하는 경우 더 많은 페이지 부재가 발생하는 현상 |
| OPR/최적 페이지 교체 | <u>앞으로 가장 오랫동안 사용되지 않을 페이지를 찾아서 교체</u> | FIFO 모순을 해결, 최소 페이지 부재율을 가지나 구현이 비현실적이다. |
| LRU/최저 사용 빈도   | <u>가장 오랫동안 사용되지 않을 페이지 교체</u>               | 호출시간을 기록해야 하는 오버헤드가 발생하나 효율적.         |
| LFU/최소 사용 빈도   | <u>사용빈도(참조된 횟수)가 가장 적은 페이지를 교체하는 기법</u> | 구역성 문제 발생                                             |
| NUR/최근 사용 전무   | <u>최근에 사용되지 않은 페이지를 교체하는 기법</u>           | 참조 비트, 변경 비트 사용. LRU 시간 오버헤드 해결            |



##### 가상메모리 배치 정책

- 프로그램의 한 블록을 주기억장치의 어디에 배치할 것인가 관리
- 주요 배치 정책 : First Fit, Best Fit, Worst Fit

| 최초적합(First Fit) | 프로그램, 데이터가 들어갈 수 있는 빈 영역의 첫 번째 분할 영역에 배치 |
| ------------------- | ------------------------------------------------------------ |
| 최적적합(Best Fit)  | 프로그램, 데이터가 들어갈 수 있는 빈 영역 중 단편화를 가장 적게 남기는 분할 영역에 배치 |
| 최악적합(Worst Fit) | 프로그램, 데이터가 들어갈 수 있는 빈 영역 중 가장 큰 영역에 배치 |



##### 단편화

- <u>주기억장치 상에서 프로그램에 의해 사용되지 못하고 낭비되는 부분적인 기억 공간</u>
- 단편화 현상의 원인은 할당된 사용자 프로그램의 크기가 그 지정된 메모리의 메모리 공간보다 작을 경우, 할당되고 남은 작은 공간들이 발생해 생긴다.



##### 단편화 종류

| 구분                       | 내용                                                         |
| -------------------------- | ------------------------------------------------------------ |
| 고정 분할 시 내/외부단편화 | 사용자 프로그램의 크기가 정해진 분할 크기에 정확히 맞지 않으면 내부단편화가 발생하고, 분할이 너무 작아서 대기 중인 작업 중 하나도 맞는 것이 없을 경우 그 분할이 사용되지 않은 상태로 남아 있게 되므로 외부단편화가 발생 |
| 가변 분할 시 외부 단편화   | 가변 분할은 분할 영역의 크기가 동적으로 변경될 수 있으므로 내부단편화는 발생하지 않지만, 외부단편화는 발생할 수 있다. |



##### 단편화 해결 방안

단편화는 통합, 압축, 프레임 등의 해결방법으로 해결한다.

| 구분   | 상세 내용                               | 특징           |
| ------ | --------------------------------------- | -------------- |
| 통합   | 인접한 단편화된 공간을 하나로 통합      | 위치 제한 없음 |
| 압축   | 분산된 단편화된 공간을 한쪽 끝에서 결합 | 메모리 한쪽 끝 |
| 프레임 | 고정된 크기 메모리 사용 내부단편화 해결 | 고정 크기      |



##### 교착상태

다중 프로세스 환경 하에 서로 다른 프로세스가 각자 자신이 소유한 자원을 포기하지 않고, 상대 프로세스의 자원을 무한대기하고 있는 상태

-> 자원의 사이클 형태라고 생각



##### 교착상태 발생조건

| 원인        | 내용                                                         |
| ----------- | ------------------------------------------------------------ |
| 상호 배제   | 프로세스가 자원을 배타적으로 점유하여 다른 프로세스가 그 자원을 사용할 수 없다. |
| 점유와 대기 | 한 프로세스가 자원을 점유하고 있으면서 또 다른 자원을 요청하여 대기하고 있는 상태 |
| 비 선점     | 한 프로세스가 점유한 자원에 대해 다른 프로세스가 선점할 수 없고, 오직 점유한 프로세스만이 해제 가능 |
| 환형 대기   | 두 개 이상의 프로세스 간 자원의 점유와 대기가 하나의 원형을 구성한 상태 |



##### 은행가 알고리즘

- 프로세스가 자원을 요구할 때 시스템은 자원을 할당한 후에도 안정 상태로 남아있게 되는 지를 <u>사전에 검사하여</u> 교착상태의 발생을 회피하는 기법
- 교착상태가 발생하지 않는 상태는 안전 상태이며, 불안정 상태에서 교착상태를 유발하는 4가지 조건(상호배제, 점유와 대기, 비선점, 환형 대기)을 충족하면 교착상태에 빠진다.

1. 자원 상황과 최대 사용량을 미리 파악
2. 프로세스의 자원 할당 요구
3. 안정 알고리즘에 의한 상황 점검
4. 안정 상태이면 할당
5. 불안정 상태이면 승인 거부



##### 교착상태 해결방안

| 해결방안 | 핵심 내용                                                    |
| -------- | ------------------------------------------------------------ |
| 예방     | 상호배제, 점유와 대기, 비선점 및 환형대기 조건의 부정        |
| 회피     | 은행가 알고리즘, Wait-die, wound-wait 알고리즘               |
| 발견     | 시스템의 상태를 감시알고리즘을 통해 교착상태 검사. 자원할당 그래프, Wait for Graph |
| 회복     | Deadlock이 없어질 때까지 프로세스를 순차적으로 Kill하여 제거 |



##### 임계영역의 개념

여러 개의 프로세스가 공유하는 데이터 및 자원에 대한 어느 한 시점에는 하나의 프로세스만 사용하도록 지정된 공유 영역



##### 상호배제의 개념

- 경쟁조건을 방지하기 위해 특정 프로세스가 공유 자원을 사용하고 있을 경우 다른 모든 프로세스가 해당 공유 자원을 사용하지 못하도록 제어하는 기법
- 둘 이상의 프로그램이 임계영역을 동시에 진입하지 못하도록 하는 기법



##### 상호배제 해결을 위한 요구조건

| 요구조건  | 구분                                                         | 관련 사항         |
| --------- | ------------------------------------------------------------ | ----------------- |
| 상호 배제 | 오직 한 개 프로세스만 임계영역에 존재할 수 있다.             | 임계영역          |
| 진행      | 임계영역 밖에 있는 프로세스가 다른 프로세스의 임계영역 진입을 막을 수 없다. | 교착상태 기아상태 |
| 한계 대기 | 어떤 프로세스도 임계영역 진입이 무한정 연기될 수 없다.       | 교착상태 기아상태 |
| 상대 속도 | 프로세스에 대한 상대적 속도에 대해서는 어떤 가정도 하지 않는다. | 교착상태 기아상태 |



##### 상호배제 연산의 예

| 항목 | enterMutualExclusion()                                       | exitMutualExclusion()                                        |
| ---- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 역할 | 임계영역 진입 전 검사과정. 다른 프로세스가 임계영역 내에 존재하는지 여부 검사 | 임계영역을 벗어날 경우 처리 과정. 임계영역을 벗어남을 시스템에게 알림. |



##### 소프트웨어적 상호배제 해결방안

| 해결방안                 | 설명                                                         |
| ------------------------ | ------------------------------------------------------------ |
| 데커 알고리즘            | 두 개의 프로세스를 위한 상호배제에 대한 최초의 소프트웨어 기법. 공유변수 : 두 개의 Boolean Flag와 int turn. 차례 설정 : turn를 자신의 프로세스에게 설정 |
| 피터슨 알고리즘          | 공유 변수 : 두 개의 Boolean Flag와 int turn. <u>의사표시</u> : 임계 영역에 진입하려면 먼저 Flag를 True로 설정 후 임계영역에 진입. <u>차례 양보</u> : turn를 다른 프로세스에게 양보 |
| 램포트 베이커리 알고리즘 | 분산처리 환경에서 유용한 상호배제 알고리즘. 수행 순서를 위한 <u>번호표 부여</u>. 낮은 번호가 먼저 임계영역을 사용 요청한 프로세스로 진입 |
| 세마포어                 | <u>운영체제 또는 프로그램 작성 내에서 지원하는 상호배제 알고리즘. 세마포어 변수 및 두 개의 연산으로 임계영역에 접근하는 잠금 장치에 대한 이론적 기반</u> |



##### 하드웨어적 상호배제 해결방안

| 해결방안          | 설명                                                         |
| ----------------- | ------------------------------------------------------------ |
| 인터럽트 사용금지 | 공유 변수가 변경되는 동안 인터럽트 발생을 허용하지 않는다. 단일 프로세서에서 가능하고 멀티 프로세서에서는 적용할 수 없다. |
| Test and Set      | H/W에서 한 워드의 내용을 검사하고 변경하는 명령어 제공.      |
| 소프트웨어 ap     | H/W에서 두 워드간의 내용을 교환할 수 명령어 제공             |



##### 세마포어

- <u>운영체제 또는 프로그램 작성 내에서 지원하는 상호배제 알고리즘</u>

- 세마포어 변수(S) 및 두 개의 연산(P, V)으로 임계영역에 접근하는 잠금 장치에 대한 이론적 기반



##### 알고리즘

| process | 알고리즘                                                     | 상태값                |
| ------- | ------------------------------------------------------------ | --------------------- |
| 초기화  | 세마포어에 하나의 대기큐를 할당하고 초기화                   | S = 1                 |
| P 연산  | P(S) 연산 : wait() 수행. while s = 0 do wait // 대기 <u>s = s - 1</u> // 독점 | S = 0, 자원 할당 상태 |
| v 연산  | V(S) 연산 : Signal() 수행. <u>s = s + 1</u>                  | S = 1, 자원 해제 상태 |



##### LRU(Least Recently Used) 알고리즘

가장 오랫동안 사용되지 않을 페이지를 교체하는 알고리즘



##### i-node(identification node)의 개념

- <u>각 파일에 대한 정보를 기억하는 약 120byte 고정된 크기의 자료구조</u>
- Unix에 의해 특수구조를 갖지 않고 사용자가 정의한 그대로의 파일
- Unix에서 i-node는 파일/디렉토리의 정보를 통해 할당, 적용, 생성, 링크, 삭제의 역할



##### i-node의 구성

| 항목        | 핵심 개념                          | 설명                                                         |
| ----------- | ---------------------------------- | ------------------------------------------------------------ |
| i-node      | 구성 정보                          | 한 파일이나 디렉터리의 모든 정보 포함. 64byte로 구성되는 테이블 |
| inode table | 하위 노드 정보                     | 한 파일 시스템에서, 파일이나 디렉터리들의 전체 i-node를 갖고 있는 테이블.  i-list |
| i-number    | 등록 정보                          | i-node가 i-list에 등록되는 entry number addressing           |
| addressing  | 실제 데이터 정보(데이터 시작 주소) | 블록 위치 정도를 13개의 필드로 관리                          |



##### i-node 포함 정보

- 소유자 정보 : 사용자 id, 그룹 id
- 접근 정보 : Access Modes, Data Block Address
- 데이터가 저장된 블록의 시작주소를 포함한 파일이나 디렉터리의 모든 정보를 포함
- 파일 정보 : 크기, 생성 시간, 최근 사용시간, 최근 변경 시간, 파일 링크 수, 유형



##### 디스크 스케줄링

운영체제가 디스크를 읽거나 쓰려는 요청을 받았을 때 우선순위를 정해 관리하는 기법

- 이동디스크 스케줄링

| FCFS(First Come First Served)  | 요청 큐에 들어온 순서대로 처리                               |
| ------------------------------ | ------------------------------------------------------------ |
| SSTF(Shortest Seek Time First) | 현재 헤드 위치에서 가장 가까운 트랙의 요청 처리              |
| SCAN(엘리베이터 알고리즘)      | 헤드가 양쪽 끝을 왕복하면서 진행방향 상의 가장 가까운 트랙의 요청을 먼저 서비스한다. C-SCAN은 항상 바깥쪽에서 안쪽으로 SCAN 수행 |
| LOOK                           | SCAN과 같이 처리하되 처리할 블록이 없으면 끝까지 가지 않고 돌아온다. C-LOOK은 항상 바깥쪽에서 안쪽으로 LOOK 수행 |
| 에센바흐 기법                  | 헤드는 C-SCAN처럼 움직이며, 예외적으로 모든 실린더는 그 실린더에 요청이 있든 없든 간에 전체 트랙이 한 바퀴 회전할 동안의 서비스를 받는다. |

- 고정디스크 스케줄링

| SLTF(Shortest Latency Time First)     | 최단 지연시간 우선 전략. Sector Queuing 기법이라고도 한다. |
| ------------------------------------- | ---------------------------------------------------------- |
| SPTF(Shortest Positioning Time First) | 최단 위치 결정시간 우선 전략                               |
| SATF(Shortest Access Time First)      | 최단 접근시간 우선 전략                                    |



##### SSTF(Shortest Seek Time First) 스케줄링

- 현재 헤드 위치에서 가장 가까운 트랙의 요청을 처리하는 디스크 스케줄링 기법
- 장점 : Throughput 극대화, Seek Time 최소화
- 단점 : 안쪽, 바깥쪽 트랙 기아현상 가능성, 응답시간 편차가 큼



##### 프로세스

프로그램은 파일 형태로 저장하여 관리되다가 실행을 시키면 동작을 한다. 이때 <u>실행중인 프로그램을 프로세스라고 한다.</u>



##### 스레드

- 한 개의 프로세스는 여러 개의 스레드로 나누어 수행될 수 있다.
- 스레드는 다중 프로그래밍 시스템에서 CPU를 받아서 수행되는 프로그램 단위이다.
- 스레드는 프로세스나 태스크보다 더 작은 단위이며, 실행 환경을 공유시켜 기억장소의 낭비가 줄어든다.



##### Multilevel Queue

- 작업들을 여러 종류의 그룹으로 분할
- 여러 개의 큐를 이용해 상위단계 작업에 의해 하위단계 작업이 선정된다.



##### Multilevel Feedback Queue

- 입출력 위주와 CPU 위주인 프로세스의 특성에 따라 큐마다 서로 다른 CPU Time Slice(Time Quantum)를 부여한다.
- 새로운 프로세스는 높은 우선순위, 프로세스의 실행시간이 길어질 수록 점점 낮은 우선순위 큐로 이동한다.
- 하위 단계일 수록 할당 시간은 증가하도록 공평성을 부여한다.